!function () { "use strict"; var t = { d: function (e, n) { for (var i in n) t.o(n, i) && !t.o(e, i) && Object.defineProperty(e, i, { enumerable: !0, get: n[i] }) }, o: function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, r: function (t) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) } }; !function () { var e = {}; t.r(e), t.d(e, { afterMain: function () { return w }, afterRead: function () { return v }, afterWrite: function () { return C }, applyStyles: function () { return D }, arrow: function () { return G }, auto: function () { return s }, basePlacements: function () { return a }, beforeMain: function () { return b }, beforeRead: function () { return m }, beforeWrite: function () { return E }, bottom: function () { return i }, clippingParents: function () { return u }, computeStyles: function () { return et }, createPopper: function () { return Lt }, createPopperBase: function () { return Ot }, createPopperLite: function () { return Dt }, detectOverflow: function () { return mt }, end: function () { return l }, eventListeners: function () { return it }, flip: function () { return _t }, hide: function () { return yt }, left: function () { return r }, main: function () { return y }, modifierPhases: function () { return x }, offset: function () { return wt }, placements: function () { return g }, popper: function () { return f }, popperGenerator: function () { return kt }, popperOffsets: function () { return Et }, preventOverflow: function () { return At }, read: function () { return _ }, reference: function () { return h }, right: function () { return o }, start: function () { return c }, top: function () { return n }, variationPlacements: function () { return p }, viewport: function () { return d }, write: function () { return A } }); var n = "top", i = "bottom", o = "right", r = "left", s = "auto", a = [n, i, o, r], c = "start", l = "end", u = "clippingParents", d = "viewport", f = "popper", h = "reference", p = a.reduce((function (t, e) { return t.concat([e + "-" + c, e + "-" + l]) }), []), g = [].concat(a, [s]).reduce((function (t, e) { return t.concat([e, e + "-" + c, e + "-" + l]) }), []), m = "beforeRead", _ = "read", v = "afterRead", b = "beforeMain", y = "main", w = "afterMain", E = "beforeWrite", A = "write", C = "afterWrite", x = [m, _, v, b, y, w, E, A, C]; function T(t) { return t ? (t.nodeName || "").toLowerCase() : null } function S(t) { if (null == t) return window; if ("[object Window]" !== t.toString()) { var e = t.ownerDocument; return e && e.defaultView || window } return t } function k(t) { return t instanceof S(t).Element || t instanceof Element } function O(t) { return t instanceof S(t).HTMLElement || t instanceof HTMLElement } function L(t) { return "undefined" != typeof ShadowRoot && (t instanceof S(t).ShadowRoot || t instanceof ShadowRoot) } var D = { name: "applyStyles", enabled: !0, phase: "write", fn: function (t) { var e = t.state; Object.keys(e.elements).forEach((function (t) { var n = e.styles[t] || {}, i = e.attributes[t] || {}, o = e.elements[t]; O(o) && T(o) && (Object.assign(o.style, n), Object.keys(i).forEach((function (t) { var e = i[t]; !1 === e ? o.removeAttribute(t) : o.setAttribute(t, !0 === e ? "" : e) }))) })) }, effect: function (t) { var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function () { Object.keys(e.elements).forEach((function (t) { var i = e.elements[t], o = e.attributes[t] || {}, r = Object.keys(e.styles.hasOwnProperty(t) ? e.styles[t] : n[t]).reduce((function (t, e) { return t[e] = "", t }), {}); O(i) && T(i) && (Object.assign(i.style, r), Object.keys(o).forEach((function (t) { i.removeAttribute(t) }))) })) } }, requires: ["computeStyles"] }; function P(t) { return t.split("-")[0] } var I = Math.max, M = Math.min, N = Math.round; function $() { var t = navigator.userAgentData; return null != t && t.brands && Array.isArray(t.brands) ? t.brands.map((function (t) { return t.brand + "/" + t.version })).join(" ") : navigator.userAgent } function j() { return !/^((?!chrome|android).)*safari/i.test($()) } function F(t, e, n) { void 0 === e && (e = !1), void 0 === n && (n = !1); var i = t.getBoundingClientRect(), o = 1, r = 1; e && O(t) && (o = t.offsetWidth > 0 && N(i.width) / t.offsetWidth || 1, r = t.offsetHeight > 0 && N(i.height) / t.offsetHeight || 1); var s = (k(t) ? S(t) : window).visualViewport, a = !j() && n, c = (i.left + (a && s ? s.offsetLeft : 0)) / o, l = (i.top + (a && s ? s.offsetTop : 0)) / r, u = i.width / o, d = i.height / r; return { width: u, height: d, top: l, right: c + u, bottom: l + d, left: c, x: c, y: l } } function z(t) { var e = F(t), n = t.offsetWidth, i = t.offsetHeight; return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - i) <= 1 && (i = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: i } } function H(t, e) { var n = e.getRootNode && e.getRootNode(); if (t.contains(e)) return !0; if (n && L(n)) { var i = e; do { if (i && t.isSameNode(i)) return !0; i = i.parentNode || i.host } while (i) } return !1 } function W(t) { return S(t).getComputedStyle(t) } function q(t) { return ["table", "td", "th"].indexOf(T(t)) >= 0 } function B(t) { return ((k(t) ? t.ownerDocument : t.document) || window.document).documentElement } function R(t) { return "html" === T(t) ? t : t.assignedSlot || t.parentNode || (L(t) ? t.host : null) || B(t) } function V(t) { return O(t) && "fixed" !== W(t).position ? t.offsetParent : null } function X(t) { for (var e = S(t), n = V(t); n && q(n) && "static" === W(n).position;)n = V(n); return n && ("html" === T(n) || "body" === T(n) && "static" === W(n).position) ? e : n || function (t) { var e = /firefox/i.test($()); if (/Trident/i.test($()) && O(t) && "fixed" === W(t).position) return null; var n = R(t); for (L(n) && (n = n.host); O(n) && ["html", "body"].indexOf(T(n)) < 0;) { var i = W(n); if ("none" !== i.transform || "none" !== i.perspective || "paint" === i.contain || -1 !== ["transform", "perspective"].indexOf(i.willChange) || e && "filter" === i.willChange || e && i.filter && "none" !== i.filter) return n; n = n.parentNode } return null }(t) || e } function K(t) { return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y" } function U(t, e, n) { return I(t, M(e, n)) } function Y(t) { return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, t) } function Q(t, e) { return e.reduce((function (e, n) { return e[n] = t, e }), {}) } var G = { name: "arrow", enabled: !0, phase: "main", fn: function (t) { var e, s = t.state, c = t.name, l = t.options, u = s.elements.arrow, d = s.modifiersData.popperOffsets, f = P(s.placement), h = K(f), p = [r, o].indexOf(f) >= 0 ? "height" : "width"; if (u && d) { var g = function (t, e) { return Y("number" != typeof (t = "function" == typeof t ? t(Object.assign({}, e.rects, { placement: e.placement })) : t) ? t : Q(t, a)) }(l.padding, s), m = z(u), _ = "y" === h ? n : r, v = "y" === h ? i : o, b = s.rects.reference[p] + s.rects.reference[h] - d[h] - s.rects.popper[p], y = d[h] - s.rects.reference[h], w = X(u), E = w ? "y" === h ? w.clientHeight || 0 : w.clientWidth || 0 : 0, A = b / 2 - y / 2, C = g[_], x = E - m[p] - g[v], T = E / 2 - m[p] / 2 + A, S = U(C, T, x), k = h; s.modifiersData[c] = ((e = {})[k] = S, e.centerOffset = S - T, e) } }, effect: function (t) { var e = t.state, n = t.options.element, i = void 0 === n ? "[data-popper-arrow]" : n; null != i && ("string" != typeof i || (i = e.elements.popper.querySelector(i))) && H(e.elements.popper, i) && (e.elements.arrow = i) }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }; function J(t) { return t.split("-")[1] } var Z = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; function tt(t) { var e, s = t.popper, a = t.popperRect, c = t.placement, u = t.variation, d = t.offsets, f = t.position, h = t.gpuAcceleration, p = t.adaptive, g = t.roundOffsets, m = t.isFixed, _ = d.x, v = void 0 === _ ? 0 : _, b = d.y, y = void 0 === b ? 0 : b, w = "function" == typeof g ? g({ x: v, y: y }) : { x: v, y: y }; v = w.x, y = w.y; var E = d.hasOwnProperty("x"), A = d.hasOwnProperty("y"), C = r, x = n, T = window; if (p) { var k = X(s), O = "clientHeight", L = "clientWidth"; k === S(s) && "static" !== W(k = B(s)).position && "absolute" === f && (O = "scrollHeight", L = "scrollWidth"), (c === n || (c === r || c === o) && u === l) && (x = i, y -= (m && k === T && T.visualViewport ? T.visualViewport.height : k[O]) - a.height, y *= h ? 1 : -1), c !== r && (c !== n && c !== i || u !== l) || (C = o, v -= (m && k === T && T.visualViewport ? T.visualViewport.width : k[L]) - a.width, v *= h ? 1 : -1) } var D, P = Object.assign({ position: f }, p && Z), I = !0 === g ? function (t, e) { var n = t.x, i = t.y, o = e.devicePixelRatio || 1; return { x: N(n * o) / o || 0, y: N(i * o) / o || 0 } }({ x: v, y: y }, S(s)) : { x: v, y: y }; return v = I.x, y = I.y, h ? Object.assign({}, P, ((D = {})[x] = A ? "0" : "", D[C] = E ? "0" : "", D.transform = (T.devicePixelRatio || 1) <= 1 ? "translate(" + v + "px, " + y + "px)" : "translate3d(" + v + "px, " + y + "px, 0)", D)) : Object.assign({}, P, ((e = {})[x] = A ? y + "px" : "", e[C] = E ? v + "px" : "", e.transform = "", e)) } var et = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: function (t) { var e = t.state, n = t.options, i = n.gpuAcceleration, o = void 0 === i || i, r = n.adaptive, s = void 0 === r || r, a = n.roundOffsets, c = void 0 === a || a, l = { placement: P(e.placement), variation: J(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: o, isFixed: "fixed" === e.options.strategy }; null != e.modifiersData.popperOffsets && (e.styles.popper = Object.assign({}, e.styles.popper, tt(Object.assign({}, l, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: s, roundOffsets: c })))), null != e.modifiersData.arrow && (e.styles.arrow = Object.assign({}, e.styles.arrow, tt(Object.assign({}, l, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: c })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement }) }, data: {} }, nt = { passive: !0 }, it = { name: "eventListeners", enabled: !0, phase: "write", fn: function () { }, effect: function (t) { var e = t.state, n = t.instance, i = t.options, o = i.scroll, r = void 0 === o || o, s = i.resize, a = void 0 === s || s, c = S(e.elements.popper), l = [].concat(e.scrollParents.reference, e.scrollParents.popper); return r && l.forEach((function (t) { t.addEventListener("scroll", n.update, nt) })), a && c.addEventListener("resize", n.update, nt), function () { r && l.forEach((function (t) { t.removeEventListener("scroll", n.update, nt) })), a && c.removeEventListener("resize", n.update, nt) } }, data: {} }, ot = { left: "right", right: "left", bottom: "top", top: "bottom" }; function rt(t) { return t.replace(/left|right|bottom|top/g, (function (t) { return ot[t] })) } var st = { start: "end", end: "start" }; function at(t) { return t.replace(/start|end/g, (function (t) { return st[t] })) } function ct(t) { var e = S(t); return { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset } } function lt(t) { return F(B(t)).left + ct(t).scrollLeft } function ut(t) { var e = W(t), n = e.overflow, i = e.overflowX, o = e.overflowY; return /auto|scroll|overlay|hidden/.test(n + o + i) } function dt(t) { return ["html", "body", "#document"].indexOf(T(t)) >= 0 ? t.ownerDocument.body : O(t) && ut(t) ? t : dt(R(t)) } function ft(t, e) { var n; void 0 === e && (e = []); var i = dt(t), o = i === (null == (n = t.ownerDocument) ? void 0 : n.body), r = S(i), s = o ? [r].concat(r.visualViewport || [], ut(i) ? i : []) : i, a = e.concat(s); return o ? a : a.concat(ft(R(s))) } function ht(t) { return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height }) } function pt(t, e, n) { return e === d ? ht(function (t, e) { var n = S(t), i = B(t), o = n.visualViewport, r = i.clientWidth, s = i.clientHeight, a = 0, c = 0; if (o) { r = o.width, s = o.height; var l = j(); (l || !l && "fixed" === e) && (a = o.offsetLeft, c = o.offsetTop) } return { width: r, height: s, x: a + lt(t), y: c } }(t, n)) : k(e) ? function (t, e) { var n = F(t, !1, "fixed" === e); return n.top = n.top + t.clientTop, n.left = n.left + t.clientLeft, n.bottom = n.top + t.clientHeight, n.right = n.left + t.clientWidth, n.width = t.clientWidth, n.height = t.clientHeight, n.x = n.left, n.y = n.top, n }(e, n) : ht(function (t) { var e, n = B(t), i = ct(t), o = null == (e = t.ownerDocument) ? void 0 : e.body, r = I(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), s = I(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), a = -i.scrollLeft + lt(t), c = -i.scrollTop; return "rtl" === W(o || n).direction && (a += I(n.clientWidth, o ? o.clientWidth : 0) - r), { width: r, height: s, x: a, y: c } }(B(t))) } function gt(t) { var e, s = t.reference, a = t.element, u = t.placement, d = u ? P(u) : null, f = u ? J(u) : null, h = s.x + s.width / 2 - a.width / 2, p = s.y + s.height / 2 - a.height / 2; switch (d) { case n: e = { x: h, y: s.y - a.height }; break; case i: e = { x: h, y: s.y + s.height }; break; case o: e = { x: s.x + s.width, y: p }; break; case r: e = { x: s.x - a.width, y: p }; break; default: e = { x: s.x, y: s.y } }var g = d ? K(d) : null; if (null != g) { var m = "y" === g ? "height" : "width"; switch (f) { case c: e[g] = e[g] - (s[m] / 2 - a[m] / 2); break; case l: e[g] = e[g] + (s[m] / 2 - a[m] / 2) } } return e } function mt(t, e) { void 0 === e && (e = {}); var r = e, s = r.placement, c = void 0 === s ? t.placement : s, l = r.strategy, p = void 0 === l ? t.strategy : l, g = r.boundary, m = void 0 === g ? u : g, _ = r.rootBoundary, v = void 0 === _ ? d : _, b = r.elementContext, y = void 0 === b ? f : b, w = r.altBoundary, E = void 0 !== w && w, A = r.padding, C = void 0 === A ? 0 : A, x = Y("number" != typeof C ? C : Q(C, a)), S = y === f ? h : f, L = t.rects.popper, D = t.elements[E ? S : y], P = function (t, e, n, i) { var o = "clippingParents" === e ? function (t) { var e = ft(R(t)), n = ["absolute", "fixed"].indexOf(W(t).position) >= 0 && O(t) ? X(t) : t; return k(n) ? e.filter((function (t) { return k(t) && H(t, n) && "body" !== T(t) })) : [] }(t) : [].concat(e), r = [].concat(o, [n]), s = r[0], a = r.reduce((function (e, n) { var o = pt(t, n, i); return e.top = I(o.top, e.top), e.right = M(o.right, e.right), e.bottom = M(o.bottom, e.bottom), e.left = I(o.left, e.left), e }), pt(t, s, i)); return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a }(k(D) ? D : D.contextElement || B(t.elements.popper), m, v, p), N = F(t.elements.reference), $ = gt({ reference: N, element: L, strategy: "absolute", placement: c }), j = ht(Object.assign({}, L, $)), z = y === f ? j : N, q = { top: P.top - z.top + x.top, bottom: z.bottom - P.bottom + x.bottom, left: P.left - z.left + x.left, right: z.right - P.right + x.right }, V = t.modifiersData.offset; if (y === f && V) { var K = V[c]; Object.keys(q).forEach((function (t) { var e = [o, i].indexOf(t) >= 0 ? 1 : -1, r = [n, i].indexOf(t) >= 0 ? "y" : "x"; q[t] += K[r] * e })) } return q } var _t = { name: "flip", enabled: !0, phase: "main", fn: function (t) { var e = t.state, l = t.options, u = t.name; if (!e.modifiersData[u]._skip) { for (var d = l.mainAxis, f = void 0 === d || d, h = l.altAxis, m = void 0 === h || h, _ = l.fallbackPlacements, v = l.padding, b = l.boundary, y = l.rootBoundary, w = l.altBoundary, E = l.flipVariations, A = void 0 === E || E, C = l.allowedAutoPlacements, x = e.options.placement, T = P(x), S = _ || (T !== x && A ? function (t) { if (P(t) === s) return []; var e = rt(t); return [at(t), e, at(e)] }(x) : [rt(x)]), k = [x].concat(S).reduce((function (t, n) { return t.concat(P(n) === s ? function (t, e) { void 0 === e && (e = {}); var n = e, i = n.placement, o = n.boundary, r = n.rootBoundary, s = n.padding, c = n.flipVariations, l = n.allowedAutoPlacements, u = void 0 === l ? g : l, d = J(i), f = d ? c ? p : p.filter((function (t) { return J(t) === d })) : a, h = f.filter((function (t) { return u.indexOf(t) >= 0 })); 0 === h.length && (h = f); var m = h.reduce((function (e, n) { return e[n] = mt(t, { placement: n, boundary: o, rootBoundary: r, padding: s })[P(n)], e }), {}); return Object.keys(m).sort((function (t, e) { return m[t] - m[e] })) }(e, { placement: n, boundary: b, rootBoundary: y, padding: v, flipVariations: A, allowedAutoPlacements: C }) : n) }), []), O = e.rects.reference, L = e.rects.popper, D = new Map, I = !0, M = k[0], N = 0; N < k.length; N++) { var $ = k[N], j = P($), F = J($) === c, z = [n, i].indexOf(j) >= 0, H = z ? "width" : "height", W = mt(e, { placement: $, boundary: b, rootBoundary: y, altBoundary: w, padding: v }), q = z ? F ? o : r : F ? i : n; O[H] > L[H] && (q = rt(q)); var B = rt(q), R = []; if (f && R.push(W[j] <= 0), m && R.push(W[q] <= 0, W[B] <= 0), R.every((function (t) { return t }))) { M = $, I = !1; break } D.set($, R) } if (I) for (var V = function (t) { var e = k.find((function (e) { var n = D.get(e); if (n) return n.slice(0, t).every((function (t) { return t })) })); if (e) return M = e, "break" }, X = A ? 3 : 1; X > 0 && "break" !== V(X); X--); e.placement !== M && (e.modifiersData[u]._skip = !0, e.placement = M, e.reset = !0) } }, requiresIfExists: ["offset"], data: { _skip: !1 } }; function vt(t, e, n) { return void 0 === n && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x } } function bt(t) { return [n, o, i, r].some((function (e) { return t[e] >= 0 })) } var yt = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: function (t) { var e = t.state, n = t.name, i = e.rects.reference, o = e.rects.popper, r = e.modifiersData.preventOverflow, s = mt(e, { elementContext: "reference" }), a = mt(e, { altBoundary: !0 }), c = vt(s, i), l = vt(a, o, r), u = bt(c), d = bt(l); e.modifiersData[n] = { referenceClippingOffsets: c, popperEscapeOffsets: l, isReferenceHidden: u, hasPopperEscaped: d }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": u, "data-popper-escaped": d }) } }, wt = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: function (t) { var e = t.state, i = t.options, s = t.name, a = i.offset, c = void 0 === a ? [0, 0] : a, l = g.reduce((function (t, i) { return t[i] = function (t, e, i) { var s = P(t), a = [r, n].indexOf(s) >= 0 ? -1 : 1, c = "function" == typeof i ? i(Object.assign({}, e, { placement: t })) : i, l = c[0], u = c[1]; return l = l || 0, u = (u || 0) * a, [r, o].indexOf(s) >= 0 ? { x: u, y: l } : { x: l, y: u } }(i, e.rects, c), t }), {}), u = l[e.placement], d = u.x, f = u.y; null != e.modifiersData.popperOffsets && (e.modifiersData.popperOffsets.x += d, e.modifiersData.popperOffsets.y += f), e.modifiersData[s] = l } }, Et = { name: "popperOffsets", enabled: !0, phase: "read", fn: function (t) { var e = t.state, n = t.name; e.modifiersData[n] = gt({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement }) }, data: {} }, At = { name: "preventOverflow", enabled: !0, phase: "main", fn: function (t) { var e = t.state, s = t.options, a = t.name, l = s.mainAxis, u = void 0 === l || l, d = s.altAxis, f = void 0 !== d && d, h = s.boundary, p = s.rootBoundary, g = s.altBoundary, m = s.padding, _ = s.tether, v = void 0 === _ || _, b = s.tetherOffset, y = void 0 === b ? 0 : b, w = mt(e, { boundary: h, rootBoundary: p, padding: m, altBoundary: g }), E = P(e.placement), A = J(e.placement), C = !A, x = K(E), T = "x" === x ? "y" : "x", S = e.modifiersData.popperOffsets, k = e.rects.reference, O = e.rects.popper, L = "function" == typeof y ? y(Object.assign({}, e.rects, { placement: e.placement })) : y, D = "number" == typeof L ? { mainAxis: L, altAxis: L } : Object.assign({ mainAxis: 0, altAxis: 0 }, L), N = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, $ = { x: 0, y: 0 }; if (S) { if (u) { var j, F = "y" === x ? n : r, H = "y" === x ? i : o, W = "y" === x ? "height" : "width", q = S[x], B = q + w[F], R = q - w[H], V = v ? -O[W] / 2 : 0, Y = A === c ? k[W] : O[W], Q = A === c ? -O[W] : -k[W], G = e.elements.arrow, Z = v && G ? z(G) : { width: 0, height: 0 }, tt = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 }, et = tt[F], nt = tt[H], it = U(0, k[W], Z[W]), ot = C ? k[W] / 2 - V - it - et - D.mainAxis : Y - it - et - D.mainAxis, rt = C ? -k[W] / 2 + V + it + nt + D.mainAxis : Q + it + nt + D.mainAxis, st = e.elements.arrow && X(e.elements.arrow), at = st ? "y" === x ? st.clientTop || 0 : st.clientLeft || 0 : 0, ct = null != (j = null == N ? void 0 : N[x]) ? j : 0, lt = q + rt - ct, ut = U(v ? M(B, q + ot - ct - at) : B, q, v ? I(R, lt) : R); S[x] = ut, $[x] = ut - q } if (f) { var dt, ft = "x" === x ? n : r, ht = "x" === x ? i : o, pt = S[T], gt = "y" === T ? "height" : "width", _t = pt + w[ft], vt = pt - w[ht], bt = -1 !== [n, r].indexOf(E), yt = null != (dt = null == N ? void 0 : N[T]) ? dt : 0, wt = bt ? _t : pt - k[gt] - O[gt] - yt + D.altAxis, Et = bt ? pt + k[gt] + O[gt] - yt - D.altAxis : vt, At = v && bt ? function (t, e, n) { var i = U(t, e, n); return i > n ? n : i }(wt, pt, Et) : U(v ? wt : _t, pt, v ? Et : vt); S[T] = At, $[T] = At - pt } e.modifiersData[a] = $ } }, requiresIfExists: ["offset"] }; function Ct(t, e, n) { void 0 === n && (n = !1); var i, o, r = O(e), s = O(e) && function (t) { var e = t.getBoundingClientRect(), n = N(e.width) / t.offsetWidth || 1, i = N(e.height) / t.offsetHeight || 1; return 1 !== n || 1 !== i }(e), a = B(e), c = F(t, s, n), l = { scrollLeft: 0, scrollTop: 0 }, u = { x: 0, y: 0 }; return (r || !r && !n) && (("body" !== T(e) || ut(a)) && (l = (i = e) !== S(i) && O(i) ? { scrollLeft: (o = i).scrollLeft, scrollTop: o.scrollTop } : ct(i)), O(e) ? ((u = F(e, !0)).x += e.clientLeft, u.y += e.clientTop) : a && (u.x = lt(a))), { x: c.left + l.scrollLeft - u.x, y: c.top + l.scrollTop - u.y, width: c.width, height: c.height } } function xt(t) { var e = new Map, n = new Set, i = []; function o(t) { n.add(t.name), [].concat(t.requires || [], t.requiresIfExists || []).forEach((function (t) { if (!n.has(t)) { var i = e.get(t); i && o(i) } })), i.push(t) } return t.forEach((function (t) { e.set(t.name, t) })), t.forEach((function (t) { n.has(t.name) || o(t) })), i } var Tt = { placement: "bottom", modifiers: [], strategy: "absolute" }; function St() { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; return !e.some((function (t) { return !(t && "function" == typeof t.getBoundingClientRect) })) } function kt(t) { void 0 === t && (t = {}); var e = t, n = e.defaultModifiers, i = void 0 === n ? [] : n, o = e.defaultOptions, r = void 0 === o ? Tt : o; return function (t, e, n) { void 0 === n && (n = r); var o, s, a = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Tt, r), modifiersData: {}, elements: { reference: t, popper: e }, attributes: {}, styles: {} }, c = [], l = !1, u = { state: a, setOptions: function (n) { var o = "function" == typeof n ? n(a.options) : n; d(), a.options = Object.assign({}, r, a.options, o), a.scrollParents = { reference: k(t) ? ft(t) : t.contextElement ? ft(t.contextElement) : [], popper: ft(e) }; var s, l, f = function (t) { var e = xt(t); return x.reduce((function (t, n) { return t.concat(e.filter((function (t) { return t.phase === n }))) }), []) }((s = [].concat(i, a.options.modifiers), l = s.reduce((function (t, e) { var n = t[e.name]; return t[e.name] = n ? Object.assign({}, n, e, { options: Object.assign({}, n.options, e.options), data: Object.assign({}, n.data, e.data) }) : e, t }), {}), Object.keys(l).map((function (t) { return l[t] })))); return a.orderedModifiers = f.filter((function (t) { return t.enabled })), a.orderedModifiers.forEach((function (t) { var e = t.name, n = t.options, i = void 0 === n ? {} : n, o = t.effect; if ("function" == typeof o) { var r = o({ state: a, name: e, instance: u, options: i }); c.push(r || function () { }) } })), u.update() }, forceUpdate: function () { if (!l) { var t = a.elements, e = t.reference, n = t.popper; if (St(e, n)) { a.rects = { reference: Ct(e, X(n), "fixed" === a.options.strategy), popper: z(n) }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach((function (t) { return a.modifiersData[t.name] = Object.assign({}, t.data) })); for (var i = 0; i < a.orderedModifiers.length; i++)if (!0 !== a.reset) { var o = a.orderedModifiers[i], r = o.fn, s = o.options, c = void 0 === s ? {} : s, d = o.name; "function" == typeof r && (a = r({ state: a, options: c, name: d, instance: u }) || a) } else a.reset = !1, i = -1 } } }, update: (o = function () { return new Promise((function (t) { u.forceUpdate(), t(a) })) }, function () { return s || (s = new Promise((function (t) { Promise.resolve().then((function () { s = void 0, t(o()) })) }))), s }), destroy: function () { d(), l = !0 } }; if (!St(t, e)) return u; function d() { c.forEach((function (t) { return t() })), c = [] } return u.setOptions(n).then((function (t) { !l && n.onFirstUpdate && n.onFirstUpdate(t) })), u } } var Ot = kt(), Lt = kt({ defaultModifiers: [it, Et, et, D, wt, _t, At, G, yt] }), Dt = kt({ defaultModifiers: [it, Et, et, D] }); const Pt = new Map, It = { set(t, e, n) { Pt.has(t) || Pt.set(t, new Map); const i = Pt.get(t); i.has(e) || 0 === i.size ? i.set(e, n) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(i.keys())[0]}.`) }, get(t, e) { return Pt.has(t) && Pt.get(t).get(e) || null }, remove(t, e) { if (!Pt.has(t)) return; const n = Pt.get(t); n.delete(e), 0 === n.size && Pt.delete(t) } }, Mt = "transitionend", Nt = t => (t && window.CSS && window.CSS.escape && (t = t.replace(/#([^\s"#']+)/g, ((t, e) => `#${CSS.escape(e)}`))), t), $t = t => { t.dispatchEvent(new Event(Mt)) }, jt = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType), Ft = t => jt(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(Nt(t)) : null, zt = t => { if (!jt(t) || 0 === t.getClientRects().length) return !1; const e = "visible" === getComputedStyle(t).getPropertyValue("visibility"), n = t.closest("details:not([open])"); if (!n) return e; if (n !== t) { const e = t.closest("summary"); if (e && e.parentNode !== n) return !1; if (null === e) return !1 } return e }, Ht = t => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")), Wt = t => { if (!document.documentElement.attachShadow) return null; if ("function" == typeof t.getRootNode) { const e = t.getRootNode(); return e instanceof ShadowRoot ? e : null } return t instanceof ShadowRoot ? t : t.parentNode ? Wt(t.parentNode) : null }, qt = () => { }, Bt = t => { t.offsetHeight }, Rt = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null, Vt = [], Xt = () => "rtl" === document.documentElement.dir, Kt = t => { var e; e = () => { const e = Rt(); if (e) { const n = t.NAME, i = e.fn[n]; e.fn[n] = t.jQueryInterface, e.fn[n].Constructor = t, e.fn[n].noConflict = () => (e.fn[n] = i, t.jQueryInterface) } }, "loading" === document.readyState ? (Vt.length || document.addEventListener("DOMContentLoaded", (() => { for (const t of Vt) t() })), Vt.push(e)) : e() }, Ut = (t, e = [], n = t) => "function" == typeof t ? t(...e) : n, Yt = (t, e, n = !0) => { if (!n) return void Ut(t); const i = (t => { if (!t) return 0; let { transitionDuration: e, transitionDelay: n } = window.getComputedStyle(t); const i = Number.parseFloat(e), o = Number.parseFloat(n); return i || o ? (e = e.split(",")[0], n = n.split(",")[0], 1e3 * (Number.parseFloat(e) + Number.parseFloat(n))) : 0 })(e) + 5; let o = !1; const r = ({ target: n }) => { n === e && (o = !0, e.removeEventListener(Mt, r), Ut(t)) }; e.addEventListener(Mt, r), setTimeout((() => { o || $t(e) }), i) }, Qt = (t, e, n, i) => { const o = t.length; let r = t.indexOf(e); return -1 === r ? !n && i ? t[o - 1] : t[0] : (r += n ? 1 : -1, i && (r = (r + o) % o), t[Math.max(0, Math.min(r, o - 1))]) }, Gt = /[^.]*(?=\..*)\.|.*/, Jt = /\..*/, Zt = /::\d+$/, te = {}; let ee = 1; const ne = { mouseenter: "mouseover", mouseleave: "mouseout" }, ie = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]); function oe(t, e) { return e && `${e}::${ee++}` || t.uidEvent || ee++ } function re(t) { const e = oe(t); return t.uidEvent = e, te[e] = te[e] || {}, te[e] } function se(t, e, n = null) { return Object.values(t).find((t => t.callable === e && t.delegationSelector === n)) } function ae(t, e, n) { const i = "string" == typeof e, o = i ? n : e || n; let r = de(t); return ie.has(r) || (r = t), [i, o, r] } function ce(t, e, n, i, o) { if ("string" != typeof e || !t) return; let [r, s, a] = ae(e, n, i); if (e in ne) { const t = t => function (e) { if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget)) return t.call(this, e) }; s = t(s) } const c = re(t), l = c[a] || (c[a] = {}), u = se(l, s, r ? n : null); if (u) return void (u.oneOff = u.oneOff && o); const d = oe(s, e.replace(Gt, "")), f = r ? function (t, e, n) { return function i(o) { const r = t.querySelectorAll(e); for (let { target: s } = o; s && s !== this; s = s.parentNode)for (const a of r) if (a === s) return he(o, { delegateTarget: s }), i.oneOff && fe.off(t, o.type, e, n), n.apply(s, [o]) } }(t, n, s) : function (t, e) { return function n(i) { return he(i, { delegateTarget: t }), n.oneOff && fe.off(t, i.type, e), e.apply(t, [i]) } }(t, s); f.delegationSelector = r ? n : null, f.callable = s, f.oneOff = o, f.uidEvent = d, l[d] = f, t.addEventListener(a, f, r) } function le(t, e, n, i, o) { const r = se(e[n], i, o); r && (t.removeEventListener(n, r, Boolean(o)), delete e[n][r.uidEvent]) } function ue(t, e, n, i) { const o = e[n] || {}; for (const [r, s] of Object.entries(o)) r.includes(i) && le(t, e, n, s.callable, s.delegationSelector) } function de(t) { return t = t.replace(Jt, ""), ne[t] || t } const fe = { on(t, e, n, i) { ce(t, e, n, i, !1) }, one(t, e, n, i) { ce(t, e, n, i, !0) }, off(t, e, n, i) { if ("string" != typeof e || !t) return; const [o, r, s] = ae(e, n, i), a = s !== e, c = re(t), l = c[s] || {}, u = e.startsWith("."); if (void 0 === r) { if (u) for (const n of Object.keys(c)) ue(t, c, n, e.slice(1)); for (const [n, i] of Object.entries(l)) { const o = n.replace(Zt, ""); a && !e.includes(o) || le(t, c, s, i.callable, i.delegationSelector) } } else { if (!Object.keys(l).length) return; le(t, c, s, r, o ? n : null) } }, trigger(t, e, n) { if ("string" != typeof e || !t) return null; const i = Rt(); let o = null, r = !0, s = !0, a = !1; e !== de(e) && i && (o = i.Event(e, n), i(t).trigger(o), r = !o.isPropagationStopped(), s = !o.isImmediatePropagationStopped(), a = o.isDefaultPrevented()); const c = he(new Event(e, { bubbles: r, cancelable: !0 }), n); return a && c.preventDefault(), s && t.dispatchEvent(c), c.defaultPrevented && o && o.preventDefault(), c } }; function he(t, e = {}) { for (const [n, i] of Object.entries(e)) try { t[n] = i } catch (e) { Object.defineProperty(t, n, { configurable: !0, get() { return i } }) } return t } function pe(t) { if ("true" === t) return !0; if ("false" === t) return !1; if (t === Number(t).toString()) return Number(t); if ("" === t || "null" === t) return null; if ("string" != typeof t) return t; try { return JSON.parse(decodeURIComponent(t)) } catch (e) { return t } } function ge(t) { return t.replace(/[A-Z]/g, (t => `-${t.toLowerCase()}`)) } const me = { setDataAttribute(t, e, n) { t.setAttribute(`data-bs-${ge(e)}`, n) }, removeDataAttribute(t, e) { t.removeAttribute(`data-bs-${ge(e)}`) }, getDataAttributes(t) { if (!t) return {}; const e = {}, n = Object.keys(t.dataset).filter((t => t.startsWith("bs") && !t.startsWith("bsConfig"))); for (const i of n) { let n = i.replace(/^bs/, ""); n = n.charAt(0).toLowerCase() + n.slice(1, n.length), e[n] = pe(t.dataset[i]) } return e }, getDataAttribute(t, e) { return pe(t.getAttribute(`data-bs-${ge(e)}`)) } }; class _e { static get Default() { return {} } static get DefaultType() { return {} } static get NAME() { throw new Error('You have to implement the static method "NAME", for each component!') } _getConfig(t) { return t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t } _configAfterMerge(t) { return t } _mergeConfigObj(t, e) { const n = jt(e) ? me.getDataAttribute(e, "config") : {}; return { ...this.constructor.Default, ..."object" == typeof n ? n : {}, ...jt(e) ? me.getDataAttributes(e) : {}, ..."object" == typeof t ? t : {} } } _typeCheckConfig(t, e = this.constructor.DefaultType) { for (const [i, o] of Object.entries(e)) { const e = t[i], r = jt(e) ? "element" : null == (n = e) ? `${n}` : Object.prototype.toString.call(n).match(/\s([a-z]+)/i)[1].toLowerCase(); if (!new RegExp(o).test(r)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${i}" provided type "${r}" but expected type "${o}".`) } var n } } class ve extends _e { constructor(t, e) { super(), (t = Ft(t)) && (this._element = t, this._config = this._getConfig(e), It.set(this._element, this.constructor.DATA_KEY, this)) } dispose() { It.remove(this._element, this.constructor.DATA_KEY), fe.off(this._element, this.constructor.EVENT_KEY); for (const t of Object.getOwnPropertyNames(this)) this[t] = null } _queueCallback(t, e, n = !0) { Yt(t, e, n) } _getConfig(t) { return t = this._mergeConfigObj(t, this._element), t = this._configAfterMerge(t), this._typeCheckConfig(t), t } static getInstance(t) { return It.get(Ft(t), this.DATA_KEY) } static getOrCreateInstance(t, e = {}) { return this.getInstance(t) || new this(t, "object" == typeof e ? e : null) } static get VERSION() { return "5.3.3" } static get DATA_KEY() { return `bs.${this.NAME}` } static get EVENT_KEY() { return `.${this.DATA_KEY}` } static eventName(t) { return `${t}${this.EVENT_KEY}` } } const be = t => { let e = t.getAttribute("data-bs-target"); if (!e || "#" === e) { let n = t.getAttribute("href"); if (!n || !n.includes("#") && !n.startsWith(".")) return null; n.includes("#") && !n.startsWith("#") && (n = `#${n.split("#")[1]}`), e = n && "#" !== n ? n.trim() : null } return e ? e.split(",").map((t => Nt(t))).join(",") : null }, ye = { find(t, e = document.documentElement) { return [].concat(...Element.prototype.querySelectorAll.call(e, t)) }, findOne(t, e = document.documentElement) { return Element.prototype.querySelector.call(e, t) }, children(t, e) { return [].concat(...t.children).filter((t => t.matches(e))) }, parents(t, e) { const n = []; let i = t.parentNode.closest(e); for (; i;)n.push(i), i = i.parentNode.closest(e); return n }, prev(t, e) { let n = t.previousElementSibling; for (; n;) { if (n.matches(e)) return [n]; n = n.previousElementSibling } return [] }, next(t, e) { let n = t.nextElementSibling; for (; n;) { if (n.matches(e)) return [n]; n = n.nextElementSibling } return [] }, focusableChildren(t) { const e = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((t => `${t}:not([tabindex^="-"])`)).join(","); return this.find(e, t).filter((t => !Ht(t) && zt(t))) }, getSelectorFromElement(t) { const e = be(t); return e && ye.findOne(e) ? e : null }, getElementFromSelector(t) { const e = be(t); return e ? ye.findOne(e) : null }, getMultipleElementsFromSelector(t) { const e = be(t); return e ? ye.find(e) : [] } }, we = (t, e = "hide") => { const n = `click.dismiss${t.EVENT_KEY}`, i = t.NAME; fe.on(document, n, `[data-bs-dismiss="${i}"]`, (function (n) { if (["A", "AREA"].includes(this.tagName) && n.preventDefault(), Ht(this)) return; const o = ye.getElementFromSelector(this) || this.closest(`.${i}`); t.getOrCreateInstance(o)[e]() })) }, Ee = ".bs.alert", Ae = `close${Ee}`, Ce = `closed${Ee}`; class xe extends ve { static get NAME() { return "alert" } close() { if (fe.trigger(this._element, Ae).defaultPrevented) return; this._element.classList.remove("show"); const t = this._element.classList.contains("fade"); this._queueCallback((() => this._destroyElement()), this._element, t) } _destroyElement() { this._element.remove(), fe.trigger(this._element, Ce), this.dispose() } static jQueryInterface(t) { return this.each((function () { const e = xe.getOrCreateInstance(this); if ("string" == typeof t) { if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`); e[t](this) } })) } } we(xe, "close"), Kt(xe); const Te = '[data-bs-toggle="button"]'; class Se extends ve { static get NAME() { return "button" } toggle() { this._element.setAttribute("aria-pressed", this._element.classList.toggle("active")) } static jQueryInterface(t) { return this.each((function () { const e = Se.getOrCreateInstance(this); "toggle" === t && e[t]() })) } } fe.on(document, "click.bs.button.data-api", Te, (t => { t.preventDefault(); const e = t.target.closest(Te); Se.getOrCreateInstance(e).toggle() })), Kt(Se); const ke = ".bs.swipe", Oe = `touchstart${ke}`, Le = `touchmove${ke}`, De = `touchend${ke}`, Pe = `pointerdown${ke}`, Ie = `pointerup${ke}`, Me = { endCallback: null, leftCallback: null, rightCallback: null }, Ne = { endCallback: "(function|null)", leftCallback: "(function|null)", rightCallback: "(function|null)" }; class $e extends _e { constructor(t, e) { super(), this._element = t, t && $e.isSupported() && (this._config = this._getConfig(e), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents()) } static get Default() { return Me } static get DefaultType() { return Ne } static get NAME() { return "swipe" } dispose() { fe.off(this._element, ke) } _start(t) { this._supportPointerEvents ? this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX) : this._deltaX = t.touches[0].clientX } _end(t) { this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX - this._deltaX), this._handleSwipe(), Ut(this._config.endCallback) } _move(t) { this._deltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this._deltaX } _handleSwipe() { const t = Math.abs(this._deltaX); if (t <= 40) return; const e = t / this._deltaX; this._deltaX = 0, e && Ut(e > 0 ? this._config.rightCallback : this._config.leftCallback) } _initEvents() { this._supportPointerEvents ? (fe.on(this._element, Pe, (t => this._start(t))), fe.on(this._element, Ie, (t => this._end(t))), this._element.classList.add("pointer-event")) : (fe.on(this._element, Oe, (t => this._start(t))), fe.on(this._element, Le, (t => this._move(t))), fe.on(this._element, De, (t => this._end(t)))) } _eventIsPointerPenTouch(t) { return this._supportPointerEvents && ("pen" === t.pointerType || "touch" === t.pointerType) } static isSupported() { return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0 } } const je = ".bs.carousel", Fe = ".data-api", ze = "ArrowLeft", He = "ArrowRight", We = "next", qe = "prev", Be = "left", Re = "right", Ve = `slide${je}`, Xe = `slid${je}`, Ke = `keydown${je}`, Ue = `mouseenter${je}`, Ye = `mouseleave${je}`, Qe = `dragstart${je}`, Ge = `load${je}${Fe}`, Je = `click${je}${Fe}`, Ze = "carousel", tn = "active", en = ".active", nn = ".carousel-item", on = en + nn, rn = { [ze]: Re, [He]: Be }, sn = { interval: 5e3, keyboard: !0, pause: "hover", ride: !1, touch: !0, wrap: !0 }, an = { interval: "(number|boolean)", keyboard: "boolean", pause: "(string|boolean)", ride: "(boolean|string)", touch: "boolean", wrap: "boolean" }; class cn extends ve { constructor(t, e) { super(t, e), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = ye.findOne(".carousel-indicators", this._element), this._addEventListeners(), this._config.ride === Ze && this.cycle() } static get Default() { return sn } static get DefaultType() { return an } static get NAME() { return "carousel" } next() { this._slide(We) } nextWhenVisible() { !document.hidden && zt(this._element) && this.next() } prev() { this._slide(qe) } pause() { this._isSliding && $t(this._element), this._clearInterval() } cycle() { this._clearInterval(), this._updateInterval(), this._interval = setInterval((() => this.nextWhenVisible()), this._config.interval) } _maybeEnableCycle() { this._config.ride && (this._isSliding ? fe.one(this._element, Xe, (() => this.cycle())) : this.cycle()) } to(t) { const e = this._getItems(); if (t > e.length - 1 || t < 0) return; if (this._isSliding) return void fe.one(this._element, Xe, (() => this.to(t))); const n = this._getItemIndex(this._getActive()); if (n === t) return; const i = t > n ? We : qe; this._slide(i, e[t]) } dispose() { this._swipeHelper && this._swipeHelper.dispose(), super.dispose() } _configAfterMerge(t) { return t.defaultInterval = t.interval, t } _addEventListeners() { this._config.keyboard && fe.on(this._element, Ke, (t => this._keydown(t))), "hover" === this._config.pause && (fe.on(this._element, Ue, (() => this.pause())), fe.on(this._element, Ye, (() => this._maybeEnableCycle()))), this._config.touch && $e.isSupported() && this._addTouchEventListeners() } _addTouchEventListeners() { for (const t of ye.find(".carousel-item img", this._element)) fe.on(t, Qe, (t => t.preventDefault())); const t = { leftCallback: () => this._slide(this._directionToOrder(Be)), rightCallback: () => this._slide(this._directionToOrder(Re)), endCallback: () => { "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout((() => this._maybeEnableCycle()), 500 + this._config.interval)) } }; this._swipeHelper = new $e(this._element, t) } _keydown(t) { if (/input|textarea/i.test(t.target.tagName)) return; const e = rn[t.key]; e && (t.preventDefault(), this._slide(this._directionToOrder(e))) } _getItemIndex(t) { return this._getItems().indexOf(t) } _setActiveIndicatorElement(t) { if (!this._indicatorsElement) return; const e = ye.findOne(en, this._indicatorsElement); e.classList.remove(tn), e.removeAttribute("aria-current"); const n = ye.findOne(`[data-bs-slide-to="${t}"]`, this._indicatorsElement); n && (n.classList.add(tn), n.setAttribute("aria-current", "true")) } _updateInterval() { const t = this._activeElement || this._getActive(); if (!t) return; const e = Number.parseInt(t.getAttribute("data-bs-interval"), 10); this._config.interval = e || this._config.defaultInterval } _slide(t, e = null) { if (this._isSliding) return; const n = this._getActive(), i = t === We, o = e || Qt(this._getItems(), n, i, this._config.wrap); if (o === n) return; const r = this._getItemIndex(o), s = e => fe.trigger(this._element, e, { relatedTarget: o, direction: this._orderToDirection(t), from: this._getItemIndex(n), to: r }); if (s(Ve).defaultPrevented) return; if (!n || !o) return; const a = Boolean(this._interval); this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(r), this._activeElement = o; const c = i ? "carousel-item-start" : "carousel-item-end", l = i ? "carousel-item-next" : "carousel-item-prev"; o.classList.add(l), Bt(o), n.classList.add(c), o.classList.add(c), this._queueCallback((() => { o.classList.remove(c, l), o.classList.add(tn), n.classList.remove(tn, l, c), this._isSliding = !1, s(Xe) }), n, this._isAnimated()), a && this.cycle() } _isAnimated() { return this._element.classList.contains("slide") } _getActive() { return ye.findOne(on, this._element) } _getItems() { return ye.find(nn, this._element) } _clearInterval() { this._interval && (clearInterval(this._interval), this._interval = null) } _directionToOrder(t) { return Xt() ? t === Be ? qe : We : t === Be ? We : qe } _orderToDirection(t) { return Xt() ? t === qe ? Be : Re : t === qe ? Re : Be } static jQueryInterface(t) { return this.each((function () { const e = cn.getOrCreateInstance(this, t); if ("number" != typeof t) { if ("string" == typeof t) { if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`); e[t]() } } else e.to(t) })) } } fe.on(document, Je, "[data-bs-slide], [data-bs-slide-to]", (function (t) { const e = ye.getElementFromSelector(this); if (!e || !e.classList.contains(Ze)) return; t.preventDefault(); const n = cn.getOrCreateInstance(e), i = this.getAttribute("data-bs-slide-to"); return i ? (n.to(i), void n._maybeEnableCycle()) : "next" === me.getDataAttribute(this, "slide") ? (n.next(), void n._maybeEnableCycle()) : (n.prev(), void n._maybeEnableCycle()) })), fe.on(window, Ge, (() => { const t = ye.find('[data-bs-ride="carousel"]'); for (const e of t) cn.getOrCreateInstance(e) })), Kt(cn); const ln = ".bs.collapse", un = `show${ln}`, dn = `shown${ln}`, fn = `hide${ln}`, hn = `hidden${ln}`, pn = `click${ln}.data-api`, gn = "show", mn = "collapse", vn = "collapsing", bn = `:scope .${mn} .${mn}`, yn = '[data-bs-toggle="collapse"]', wn = { parent: null, toggle: !0 }, En = { parent: "(null|element)", toggle: "boolean" }; class An extends ve { constructor(t, e) { super(t, e), this._isTransitioning = !1, this._triggerArray = []; const n = ye.find(yn); for (const t of n) { const e = ye.getSelectorFromElement(t), n = ye.find(e).filter((t => t === this._element)); null !== e && n.length && this._triggerArray.push(t) } this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle() } static get Default() { return wn } static get DefaultType() { return En } static get NAME() { return "collapse" } toggle() { this._isShown() ? this.hide() : this.show() } show() { if (this._isTransitioning || this._isShown()) return; let t = []; if (this._config.parent && (t = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter((t => t !== this._element)).map((t => An.getOrCreateInstance(t, { toggle: !1 })))), t.length && t[0]._isTransitioning) return; if (fe.trigger(this._element, un).defaultPrevented) return; for (const e of t) e.hide(); const e = this._getDimension(); this._element.classList.remove(mn), this._element.classList.add(vn), this._element.style[e] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0; const n = `scroll${e[0].toUpperCase() + e.slice(1)}`; this._queueCallback((() => { this._isTransitioning = !1, this._element.classList.remove(vn), this._element.classList.add(mn, gn), this._element.style[e] = "", fe.trigger(this._element, dn) }), this._element, !0), this._element.style[e] = `${this._element[n]}px` } hide() { if (this._isTransitioning || !this._isShown()) return; if (fe.trigger(this._element, fn).defaultPrevented) return; const t = this._getDimension(); this._element.style[t] = `${this._element.getBoundingClientRect()[t]}px`, Bt(this._element), this._element.classList.add(vn), this._element.classList.remove(mn, gn); for (const t of this._triggerArray) { const e = ye.getElementFromSelector(t); e && !this._isShown(e) && this._addAriaAndCollapsedClass([t], !1) } this._isTransitioning = !0, this._element.style[t] = "", this._queueCallback((() => { this._isTransitioning = !1, this._element.classList.remove(vn), this._element.classList.add(mn), fe.trigger(this._element, hn) }), this._element, !0) } _isShown(t = this._element) { return t.classList.contains(gn) } _configAfterMerge(t) { return t.toggle = Boolean(t.toggle), t.parent = Ft(t.parent), t } _getDimension() { return this._element.classList.contains("collapse-horizontal") ? "width" : "height" } _initializeChildren() { if (!this._config.parent) return; const t = this._getFirstLevelChildren(yn); for (const e of t) { const t = ye.getElementFromSelector(e); t && this._addAriaAndCollapsedClass([e], this._isShown(t)) } } _getFirstLevelChildren(t) { const e = ye.find(bn, this._config.parent); return ye.find(t, this._config.parent).filter((t => !e.includes(t))) } _addAriaAndCollapsedClass(t, e) { if (t.length) for (const n of t) n.classList.toggle("collapsed", !e), n.setAttribute("aria-expanded", e) } static jQueryInterface(t) { const e = {}; return "string" == typeof t && /show|hide/.test(t) && (e.toggle = !1), this.each((function () { const n = An.getOrCreateInstance(this, e); if ("string" == typeof t) { if (void 0 === n[t]) throw new TypeError(`No method named "${t}"`); n[t]() } })) } } fe.on(document, pn, yn, (function (t) { ("A" === t.target.tagName || t.delegateTarget && "A" === t.delegateTarget.tagName) && t.preventDefault(); for (const t of ye.getMultipleElementsFromSelector(this)) An.getOrCreateInstance(t, { toggle: !1 }).toggle() })), Kt(An); const Cn = "dropdown", xn = ".bs.dropdown", Tn = ".data-api", Sn = "ArrowUp", kn = "ArrowDown", On = `hide${xn}`, Ln = `hidden${xn}`, Dn = `show${xn}`, Pn = `shown${xn}`, In = `click${xn}${Tn}`, Mn = `keydown${xn}${Tn}`, Nn = `keyup${xn}${Tn}`, $n = "show", jn = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)', Fn = `${jn}.${$n}`, zn = ".dropdown-menu", Hn = Xt() ? "top-end" : "top-start", Wn = Xt() ? "top-start" : "top-end", qn = Xt() ? "bottom-end" : "bottom-start", Bn = Xt() ? "bottom-start" : "bottom-end", Rn = Xt() ? "left-start" : "right-start", Vn = Xt() ? "right-start" : "left-start", Xn = { autoClose: !0, boundary: "clippingParents", display: "dynamic", offset: [0, 2], popperConfig: null, reference: "toggle" }, Kn = { autoClose: "(boolean|string)", boundary: "(string|element)", display: "string", offset: "(array|string|function)", popperConfig: "(null|object|function)", reference: "(string|element|object)" }; class Un extends ve { constructor(t, e) { super(t, e), this._popper = null, this._parent = this._element.parentNode, this._menu = ye.next(this._element, zn)[0] || ye.prev(this._element, zn)[0] || ye.findOne(zn, this._parent), this._inNavbar = this._detectNavbar() } static get Default() { return Xn } static get DefaultType() { return Kn } static get NAME() { return Cn } toggle() { return this._isShown() ? this.hide() : this.show() } show() { if (Ht(this._element) || this._isShown()) return; const t = { relatedTarget: this._element }; if (!fe.trigger(this._element, Dn, t).defaultPrevented) { if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(".navbar-nav")) for (const t of [].concat(...document.body.children)) fe.on(t, "mouseover", qt); this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add($n), this._element.classList.add($n), fe.trigger(this._element, Pn, t) } } hide() { if (Ht(this._element) || !this._isShown()) return; const t = { relatedTarget: this._element }; this._completeHide(t) } dispose() { this._popper && this._popper.destroy(), super.dispose() } update() { this._inNavbar = this._detectNavbar(), this._popper && this._popper.update() } _completeHide(t) { if (!fe.trigger(this._element, On, t).defaultPrevented) { if ("ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children)) fe.off(t, "mouseover", qt); this._popper && this._popper.destroy(), this._menu.classList.remove($n), this._element.classList.remove($n), this._element.setAttribute("aria-expanded", "false"), me.removeDataAttribute(this._menu, "popper"), fe.trigger(this._element, Ln, t) } } _getConfig(t) { if ("object" == typeof (t = super._getConfig(t)).reference && !jt(t.reference) && "function" != typeof t.reference.getBoundingClientRect) throw new TypeError(`${Cn.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`); return t } _createPopper() { if (void 0 === e) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)"); let t = this._element; "parent" === this._config.reference ? t = this._parent : jt(this._config.reference) ? t = Ft(this._config.reference) : "object" == typeof this._config.reference && (t = this._config.reference); const n = this._getPopperConfig(); this._popper = Lt(t, this._menu, n) } _isShown() { return this._menu.classList.contains($n) } _getPlacement() { const t = this._parent; if (t.classList.contains("dropend")) return Rn; if (t.classList.contains("dropstart")) return Vn; if (t.classList.contains("dropup-center")) return "top"; if (t.classList.contains("dropdown-center")) return "bottom"; const e = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim(); return t.classList.contains("dropup") ? e ? Wn : Hn : e ? Bn : qn } _detectNavbar() { return null !== this._element.closest(".navbar") } _getOffset() { const { offset: t } = this._config; return "string" == typeof t ? t.split(",").map((t => Number.parseInt(t, 10))) : "function" == typeof t ? e => t(e, this._element) : t } _getPopperConfig() { const t = { placement: this._getPlacement(), modifiers: [{ name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "offset", options: { offset: this._getOffset() } }] }; return (this._inNavbar || "static" === this._config.display) && (me.setDataAttribute(this._menu, "popper", "static"), t.modifiers = [{ name: "applyStyles", enabled: !1 }]), { ...t, ...Ut(this._config.popperConfig, [t]) } } _selectMenuItem({ key: t, target: e }) { const n = ye.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter((t => zt(t))); n.length && Qt(n, e, t === kn, !n.includes(e)).focus() } static jQueryInterface(t) { return this.each((function () { const e = Un.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t]() } })) } static clearMenus(t) { if (2 === t.button || "keyup" === t.type && "Tab" !== t.key) return; const e = ye.find(Fn); for (const n of e) { const e = Un.getInstance(n); if (!e || !1 === e._config.autoClose) continue; const i = t.composedPath(), o = i.includes(e._menu); if (i.includes(e._element) || "inside" === e._config.autoClose && !o || "outside" === e._config.autoClose && o) continue; if (e._menu.contains(t.target) && ("keyup" === t.type && "Tab" === t.key || /input|select|option|textarea|form/i.test(t.target.tagName))) continue; const r = { relatedTarget: e._element }; "click" === t.type && (r.clickEvent = t), e._completeHide(r) } } static dataApiKeydownHandler(t) { const e = /input|textarea/i.test(t.target.tagName), n = "Escape" === t.key, i = [Sn, kn].includes(t.key); if (!i && !n) return; if (e && !n) return; t.preventDefault(); const o = this.matches(jn) ? this : ye.prev(this, jn)[0] || ye.next(this, jn)[0] || ye.findOne(jn, t.delegateTarget.parentNode), r = Un.getOrCreateInstance(o); if (i) return t.stopPropagation(), r.show(), void r._selectMenuItem(t); r._isShown() && (t.stopPropagation(), r.hide(), o.focus()) } } fe.on(document, Mn, jn, Un.dataApiKeydownHandler), fe.on(document, Mn, zn, Un.dataApiKeydownHandler), fe.on(document, In, Un.clearMenus), fe.on(document, Nn, Un.clearMenus), fe.on(document, In, jn, (function (t) { t.preventDefault(), Un.getOrCreateInstance(this).toggle() })), Kt(Un); const Yn = "backdrop", Qn = "show", Gn = `mousedown.bs.${Yn}`, Jn = { className: "modal-backdrop", clickCallback: null, isAnimated: !1, isVisible: !0, rootElement: "body" }, Zn = { className: "string", clickCallback: "(function|null)", isAnimated: "boolean", isVisible: "boolean", rootElement: "(element|string)" }; class ti extends _e { constructor(t) { super(), this._config = this._getConfig(t), this._isAppended = !1, this._element = null } static get Default() { return Jn } static get DefaultType() { return Zn } static get NAME() { return Yn } show(t) { if (!this._config.isVisible) return void Ut(t); this._append(); const e = this._getElement(); this._config.isAnimated && Bt(e), e.classList.add(Qn), this._emulateAnimation((() => { Ut(t) })) } hide(t) { this._config.isVisible ? (this._getElement().classList.remove(Qn), this._emulateAnimation((() => { this.dispose(), Ut(t) }))) : Ut(t) } dispose() { this._isAppended && (fe.off(this._element, Gn), this._element.remove(), this._isAppended = !1) } _getElement() { if (!this._element) { const t = document.createElement("div"); t.className = this._config.className, this._config.isAnimated && t.classList.add("fade"), this._element = t } return this._element } _configAfterMerge(t) { return t.rootElement = Ft(t.rootElement), t } _append() { if (this._isAppended) return; const t = this._getElement(); this._config.rootElement.append(t), fe.on(t, Gn, (() => { Ut(this._config.clickCallback) })), this._isAppended = !0 } _emulateAnimation(t) { Yt(t, this._getElement(), this._config.isAnimated) } } const ei = ".bs.focustrap", ni = `focusin${ei}`, ii = `keydown.tab${ei}`, oi = "backward", ri = { autofocus: !0, trapElement: null }, si = { autofocus: "boolean", trapElement: "element" }; class ai extends _e { constructor(t) { super(), this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null } static get Default() { return ri } static get DefaultType() { return si } static get NAME() { return "focustrap" } activate() { this._isActive || (this._config.autofocus && this._config.trapElement.focus(), fe.off(document, ei), fe.on(document, ni, (t => this._handleFocusin(t))), fe.on(document, ii, (t => this._handleKeydown(t))), this._isActive = !0) } deactivate() { this._isActive && (this._isActive = !1, fe.off(document, ei)) } _handleFocusin(t) { const { trapElement: e } = this._config; if (t.target === document || t.target === e || e.contains(t.target)) return; const n = ye.focusableChildren(e); 0 === n.length ? e.focus() : this._lastTabNavDirection === oi ? n[n.length - 1].focus() : n[0].focus() } _handleKeydown(t) { "Tab" === t.key && (this._lastTabNavDirection = t.shiftKey ? oi : "forward") } } const ci = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", li = ".sticky-top", ui = "padding-right", di = "margin-right"; class fi { constructor() { this._element = document.body } getWidth() { const t = document.documentElement.clientWidth; return Math.abs(window.innerWidth - t) } hide() { const t = this.getWidth(); this._disableOverFlow(), this._setElementAttributes(this._element, ui, (e => e + t)), this._setElementAttributes(ci, ui, (e => e + t)), this._setElementAttributes(li, di, (e => e - t)) } reset() { this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, ui), this._resetElementAttributes(ci, ui), this._resetElementAttributes(li, di) } isOverflowing() { return this.getWidth() > 0 } _disableOverFlow() { this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden" } _setElementAttributes(t, e, n) { const i = this.getWidth(); this._applyManipulationCallback(t, (t => { if (t !== this._element && window.innerWidth > t.clientWidth + i) return; this._saveInitialAttribute(t, e); const o = window.getComputedStyle(t).getPropertyValue(e); t.style.setProperty(e, `${n(Number.parseFloat(o))}px`) })) } _saveInitialAttribute(t, e) { const n = t.style.getPropertyValue(e); n && me.setDataAttribute(t, e, n) } _resetElementAttributes(t, e) { this._applyManipulationCallback(t, (t => { const n = me.getDataAttribute(t, e); null !== n ? (me.removeDataAttribute(t, e), t.style.setProperty(e, n)) : t.style.removeProperty(e) })) } _applyManipulationCallback(t, e) { if (jt(t)) e(t); else for (const n of ye.find(t, this._element)) e(n) } } const hi = ".bs.modal", pi = `hide${hi}`, gi = `hidePrevented${hi}`, mi = `hidden${hi}`, _i = `show${hi}`, vi = `shown${hi}`, bi = `resize${hi}`, yi = `click.dismiss${hi}`, wi = `mousedown.dismiss${hi}`, Ei = `keydown.dismiss${hi}`, Ai = `click${hi}.data-api`, Ci = "modal-open", xi = "show", Ti = "modal-static", Si = { backdrop: !0, focus: !0, keyboard: !0 }, ki = { backdrop: "(boolean|string)", focus: "boolean", keyboard: "boolean" }; class Oi extends ve { constructor(t, e) { super(t, e), this._dialog = ye.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new fi, this._addEventListeners() } static get Default() { return Si } static get DefaultType() { return ki } static get NAME() { return "modal" } toggle(t) { return this._isShown ? this.hide() : this.show(t) } show(t) { this._isShown || this._isTransitioning || fe.trigger(this._element, _i, { relatedTarget: t }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(Ci), this._adjustDialog(), this._backdrop.show((() => this._showElement(t)))) } hide() { this._isShown && !this._isTransitioning && (fe.trigger(this._element, pi).defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(xi), this._queueCallback((() => this._hideModal()), this._element, this._isAnimated()))) } dispose() { fe.off(window, hi), fe.off(this._dialog, hi), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() } handleUpdate() { this._adjustDialog() } _initializeBackDrop() { return new ti({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() }) } _initializeFocusTrap() { return new ai({ trapElement: this._element }) } _showElement(t) { document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0; const e = ye.findOne(".modal-body", this._dialog); e && (e.scrollTop = 0), Bt(this._element), this._element.classList.add(xi), this._queueCallback((() => { this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, fe.trigger(this._element, vi, { relatedTarget: t }) }), this._dialog, this._isAnimated()) } _addEventListeners() { fe.on(this._element, Ei, (t => { "Escape" === t.key && (this._config.keyboard ? this.hide() : this._triggerBackdropTransition()) })), fe.on(window, bi, (() => { this._isShown && !this._isTransitioning && this._adjustDialog() })), fe.on(this._element, wi, (t => { fe.one(this._element, yi, (e => { this._element === t.target && this._element === e.target && ("static" !== this._config.backdrop ? this._config.backdrop && this.hide() : this._triggerBackdropTransition()) })) })) } _hideModal() { this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide((() => { document.body.classList.remove(Ci), this._resetAdjustments(), this._scrollBar.reset(), fe.trigger(this._element, mi) })) } _isAnimated() { return this._element.classList.contains("fade") } _triggerBackdropTransition() { if (fe.trigger(this._element, gi).defaultPrevented) return; const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._element.style.overflowY; "hidden" === e || this._element.classList.contains(Ti) || (t || (this._element.style.overflowY = "hidden"), this._element.classList.add(Ti), this._queueCallback((() => { this._element.classList.remove(Ti), this._queueCallback((() => { this._element.style.overflowY = e }), this._dialog) }), this._dialog), this._element.focus()) } _adjustDialog() { const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._scrollBar.getWidth(), n = e > 0; if (n && !t) { const t = Xt() ? "paddingLeft" : "paddingRight"; this._element.style[t] = `${e}px` } if (!n && t) { const t = Xt() ? "paddingRight" : "paddingLeft"; this._element.style[t] = `${e}px` } } _resetAdjustments() { this._element.style.paddingLeft = "", this._element.style.paddingRight = "" } static jQueryInterface(t, e) { return this.each((function () { const n = Oi.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === n[t]) throw new TypeError(`No method named "${t}"`); n[t](e) } })) } } fe.on(document, Ai, '[data-bs-toggle="modal"]', (function (t) { const e = ye.getElementFromSelector(this);["A", "AREA"].includes(this.tagName) && t.preventDefault(), fe.one(e, _i, (t => { t.defaultPrevented || fe.one(e, mi, (() => { zt(this) && this.focus() })) })); const n = ye.findOne(".modal.show"); n && Oi.getInstance(n).hide(), Oi.getOrCreateInstance(e).toggle(this) })), we(Oi), Kt(Oi); const Li = ".bs.offcanvas", Di = ".data-api", Pi = `load${Li}${Di}`, Ii = "show", Mi = "showing", Ni = "hiding", $i = ".offcanvas.show", ji = `show${Li}`, Fi = `shown${Li}`, zi = `hide${Li}`, Hi = `hidePrevented${Li}`, Wi = `hidden${Li}`, qi = `resize${Li}`, Bi = `click${Li}${Di}`, Ri = `keydown.dismiss${Li}`, Vi = { backdrop: !0, keyboard: !0, scroll: !1 }, Xi = { backdrop: "(boolean|string)", keyboard: "boolean", scroll: "boolean" }; class Ki extends ve { constructor(t, e) { super(t, e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners() } static get Default() { return Vi } static get DefaultType() { return Xi } static get NAME() { return "offcanvas" } toggle(t) { return this._isShown ? this.hide() : this.show(t) } show(t) { this._isShown || fe.trigger(this._element, ji, { relatedTarget: t }).defaultPrevented || (this._isShown = !0, this._backdrop.show(), this._config.scroll || (new fi).hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(Mi), this._queueCallback((() => { this._config.scroll && !this._config.backdrop || this._focustrap.activate(), this._element.classList.add(Ii), this._element.classList.remove(Mi), fe.trigger(this._element, Fi, { relatedTarget: t }) }), this._element, !0)) } hide() { this._isShown && (fe.trigger(this._element, zi).defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add(Ni), this._backdrop.hide(), this._queueCallback((() => { this._element.classList.remove(Ii, Ni), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || (new fi).reset(), fe.trigger(this._element, Wi) }), this._element, !0))) } dispose() { this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() } _initializeBackDrop() { const t = Boolean(this._config.backdrop); return new ti({ className: "offcanvas-backdrop", isVisible: t, isAnimated: !0, rootElement: this._element.parentNode, clickCallback: t ? () => { "static" !== this._config.backdrop ? this.hide() : fe.trigger(this._element, Hi) } : null }) } _initializeFocusTrap() { return new ai({ trapElement: this._element }) } _addEventListeners() { fe.on(this._element, Ri, (t => { "Escape" === t.key && (this._config.keyboard ? this.hide() : fe.trigger(this._element, Hi)) })) } static jQueryInterface(t) { return this.each((function () { const e = Ki.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`); e[t](this) } })) } } fe.on(document, Bi, '[data-bs-toggle="offcanvas"]', (function (t) { const e = ye.getElementFromSelector(this); if (["A", "AREA"].includes(this.tagName) && t.preventDefault(), Ht(this)) return; fe.one(e, Wi, (() => { zt(this) && this.focus() })); const n = ye.findOne($i); n && n !== e && Ki.getInstance(n).hide(), Ki.getOrCreateInstance(e).toggle(this) })), fe.on(window, Pi, (() => { for (const t of ye.find($i)) Ki.getOrCreateInstance(t).show() })), fe.on(window, qi, (() => { for (const t of ye.find("[aria-modal][class*=show][class*=offcanvas-]")) "fixed" !== getComputedStyle(t).position && Ki.getOrCreateInstance(t).hide() })), we(Ki), Kt(Ki); const Ui = { "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i], a: ["target", "href", "title", "rel"], area: [], b: [], br: [], col: [], code: [], dd: [], div: [], dl: [], dt: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ["src", "srcset", "alt", "title", "width", "height"], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }, Yi = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]), Qi = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i, Gi = (t, e) => { const n = t.nodeName.toLowerCase(); return e.includes(n) ? !Yi.has(n) || Boolean(Qi.test(t.nodeValue)) : e.filter((t => t instanceof RegExp)).some((t => t.test(n))) }, Ji = { allowList: Ui, content: {}, extraClass: "", html: !1, sanitize: !0, sanitizeFn: null, template: "<div></div>" }, Zi = { allowList: "object", content: "object", extraClass: "(string|function)", html: "boolean", sanitize: "boolean", sanitizeFn: "(null|function)", template: "string" }, to = { entry: "(string|element|function|null)", selector: "(string|element)" }; class eo extends _e { constructor(t) { super(), this._config = this._getConfig(t) } static get Default() { return Ji } static get DefaultType() { return Zi } static get NAME() { return "TemplateFactory" } getContent() { return Object.values(this._config.content).map((t => this._resolvePossibleFunction(t))).filter(Boolean) } hasContent() { return this.getContent().length > 0 } changeContent(t) { return this._checkContent(t), this._config.content = { ...this._config.content, ...t }, this } toHtml() { const t = document.createElement("div"); t.innerHTML = this._maybeSanitize(this._config.template); for (const [e, n] of Object.entries(this._config.content)) this._setContent(t, n, e); const e = t.children[0], n = this._resolvePossibleFunction(this._config.extraClass); return n && e.classList.add(...n.split(" ")), e } _typeCheckConfig(t) { super._typeCheckConfig(t), this._checkContent(t.content) } _checkContent(t) { for (const [e, n] of Object.entries(t)) super._typeCheckConfig({ selector: e, entry: n }, to) } _setContent(t, e, n) { const i = ye.findOne(n, t); i && ((e = this._resolvePossibleFunction(e)) ? jt(e) ? this._putElementInTemplate(Ft(e), i) : this._config.html ? i.innerHTML = this._maybeSanitize(e) : i.textContent = e : i.remove()) } _maybeSanitize(t) { return this._config.sanitize ? function (t, e, n) { if (!t.length) return t; if (n && "function" == typeof n) return n(t); const i = (new window.DOMParser).parseFromString(t, "text/html"), o = [].concat(...i.body.querySelectorAll("*")); for (const t of o) { const n = t.nodeName.toLowerCase(); if (!Object.keys(e).includes(n)) { t.remove(); continue } const i = [].concat(...t.attributes), o = [].concat(e["*"] || [], e[n] || []); for (const e of i) Gi(e, o) || t.removeAttribute(e.nodeName) } return i.body.innerHTML }(t, this._config.allowList, this._config.sanitizeFn) : t } _resolvePossibleFunction(t) { return Ut(t, [this]) } _putElementInTemplate(t, e) { if (this._config.html) return e.innerHTML = "", void e.append(t); e.textContent = t.textContent } } const no = new Set(["sanitize", "allowList", "sanitizeFn"]), io = "fade", oo = "show", ro = ".tooltip-inner", so = ".modal", ao = "hide.bs.modal", co = "hover", lo = "focus", uo = { AUTO: "auto", TOP: "top", RIGHT: Xt() ? "left" : "right", BOTTOM: "bottom", LEFT: Xt() ? "right" : "left" }, fo = { allowList: Ui, animation: !0, boundary: "clippingParents", container: !1, customClass: "", delay: 0, fallbackPlacements: ["top", "right", "bottom", "left"], html: !1, offset: [0, 6], placement: "top", popperConfig: null, sanitize: !0, sanitizeFn: null, selector: !1, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', title: "", trigger: "hover focus" }, ho = { allowList: "object", animation: "boolean", boundary: "(string|element)", container: "(string|element|boolean)", customClass: "(string|function)", delay: "(number|object)", fallbackPlacements: "array", html: "boolean", offset: "(array|string|function)", placement: "(string|function)", popperConfig: "(null|object|function)", sanitize: "boolean", sanitizeFn: "(null|function)", selector: "(string|boolean)", template: "string", title: "(string|element|function)", trigger: "string" }; class po extends ve { constructor(t, n) { if (void 0 === e) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)"); super(t, n), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle() } static get Default() { return fo } static get DefaultType() { return ho } static get NAME() { return "tooltip" } enable() { this._isEnabled = !0 } disable() { this._isEnabled = !1 } toggleEnabled() { this._isEnabled = !this._isEnabled } toggle() { this._isEnabled && (this._activeTrigger.click = !this._activeTrigger.click, this._isShown() ? this._leave() : this._enter()) } dispose() { clearTimeout(this._timeout), fe.off(this._element.closest(so), ao, this._hideModalHandler), this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")), this._disposePopper(), super.dispose() } show() { if ("none" === this._element.style.display) throw new Error("Please use show on visible elements"); if (!this._isWithContent() || !this._isEnabled) return; const t = fe.trigger(this._element, this.constructor.eventName("show")), e = (Wt(this._element) || this._element.ownerDocument.documentElement).contains(this._element); if (t.defaultPrevented || !e) return; this._disposePopper(); const n = this._getTipElement(); this._element.setAttribute("aria-describedby", n.getAttribute("id")); const { container: i } = this._config; if (this._element.ownerDocument.documentElement.contains(this.tip) || (i.append(n), fe.trigger(this._element, this.constructor.eventName("inserted"))), this._popper = this._createPopper(n), n.classList.add(oo), "ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children)) fe.on(t, "mouseover", qt); this._queueCallback((() => { fe.trigger(this._element, this.constructor.eventName("shown")), !1 === this._isHovered && this._leave(), this._isHovered = !1 }), this.tip, this._isAnimated()) } hide() { if (this._isShown() && !fe.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented) { if (this._getTipElement().classList.remove(oo), "ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children)) fe.off(t, "mouseover", qt); this._activeTrigger.click = !1, this._activeTrigger[lo] = !1, this._activeTrigger[co] = !1, this._isHovered = null, this._queueCallback((() => { this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), fe.trigger(this._element, this.constructor.eventName("hidden"))) }), this.tip, this._isAnimated()) } } update() { this._popper && this._popper.update() } _isWithContent() { return Boolean(this._getTitle()) } _getTipElement() { return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip } _createTipElement(t) { const e = this._getTemplateFactory(t).toHtml(); if (!e) return null; e.classList.remove(io, oo), e.classList.add(`bs-${this.constructor.NAME}-auto`); const n = (t => { do { t += Math.floor(1e6 * Math.random()) } while (document.getElementById(t)); return t })(this.constructor.NAME).toString(); return e.setAttribute("id", n), this._isAnimated() && e.classList.add(io), e } setContent(t) { this._newContent = t, this._isShown() && (this._disposePopper(), this.show()) } _getTemplateFactory(t) { return this._templateFactory ? this._templateFactory.changeContent(t) : this._templateFactory = new eo({ ...this._config, content: t, extraClass: this._resolvePossibleFunction(this._config.customClass) }), this._templateFactory } _getContentForTemplate() { return { [ro]: this._getTitle() } } _getTitle() { return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title") } _initializeOnDelegatedTarget(t) { return this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig()) } _isAnimated() { return this._config.animation || this.tip && this.tip.classList.contains(io) } _isShown() { return this.tip && this.tip.classList.contains(oo) } _createPopper(t) { const e = Ut(this._config.placement, [this, t, this._element]), n = uo[e.toUpperCase()]; return Lt(this._element, t, this._getPopperConfig(n)) } _getOffset() { const { offset: t } = this._config; return "string" == typeof t ? t.split(",").map((t => Number.parseInt(t, 10))) : "function" == typeof t ? e => t(e, this._element) : t } _resolvePossibleFunction(t) { return Ut(t, [this._element]) } _getPopperConfig(t) { const e = { placement: t, modifiers: [{ name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: "offset", options: { offset: this._getOffset() } }, { name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } }, { name: "preSetPlacement", enabled: !0, phase: "beforeMain", fn: t => { this._getTipElement().setAttribute("data-popper-placement", t.state.placement) } }] }; return { ...e, ...Ut(this._config.popperConfig, [e]) } } _setListeners() { const t = this._config.trigger.split(" "); for (const e of t) if ("click" === e) fe.on(this._element, this.constructor.eventName("click"), this._config.selector, (t => { this._initializeOnDelegatedTarget(t).toggle() })); else if ("manual" !== e) { const t = e === co ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin"), n = e === co ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout"); fe.on(this._element, t, this._config.selector, (t => { const e = this._initializeOnDelegatedTarget(t); e._activeTrigger["focusin" === t.type ? lo : co] = !0, e._enter() })), fe.on(this._element, n, this._config.selector, (t => { const e = this._initializeOnDelegatedTarget(t); e._activeTrigger["focusout" === t.type ? lo : co] = e._element.contains(t.relatedTarget), e._leave() })) } this._hideModalHandler = () => { this._element && this.hide() }, fe.on(this._element.closest(so), ao, this._hideModalHandler) } _fixTitle() { const t = this._element.getAttribute("title"); t && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", t), this._element.setAttribute("data-bs-original-title", t), this._element.removeAttribute("title")) } _enter() { this._isShown() || this._isHovered ? this._isHovered = !0 : (this._isHovered = !0, this._setTimeout((() => { this._isHovered && this.show() }), this._config.delay.show)) } _leave() { this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout((() => { this._isHovered || this.hide() }), this._config.delay.hide)) } _setTimeout(t, e) { clearTimeout(this._timeout), this._timeout = setTimeout(t, e) } _isWithActiveTrigger() { return Object.values(this._activeTrigger).includes(!0) } _getConfig(t) { const e = me.getDataAttributes(this._element); for (const t of Object.keys(e)) no.has(t) && delete e[t]; return t = { ...e, ..."object" == typeof t && t ? t : {} }, t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t } _configAfterMerge(t) { return t.container = !1 === t.container ? document.body : Ft(t.container), "number" == typeof t.delay && (t.delay = { show: t.delay, hide: t.delay }), "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), t } _getDelegateConfig() { const t = {}; for (const [e, n] of Object.entries(this._config)) this.constructor.Default[e] !== n && (t[e] = n); return t.selector = !1, t.trigger = "manual", t } _disposePopper() { this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null) } static jQueryInterface(t) { return this.each((function () { const e = po.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t]() } })) } } Kt(po); const go = ".popover-header", mo = ".popover-body", _o = { ...po.Default, content: "", offset: [0, 8], placement: "right", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>', trigger: "click" }, vo = { ...po.DefaultType, content: "(null|string|element|function)" }; class bo extends po { static get Default() { return _o } static get DefaultType() { return vo } static get NAME() { return "popover" } _isWithContent() { return this._getTitle() || this._getContent() } _getContentForTemplate() { return { [go]: this._getTitle(), [mo]: this._getContent() } } _getContent() { return this._resolvePossibleFunction(this._config.content) } static jQueryInterface(t) { return this.each((function () { const e = bo.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t]() } })) } } Kt(bo); const yo = ".bs.scrollspy", wo = `activate${yo}`, Eo = `click${yo}`, Ao = `load${yo}.data-api`, Co = "active", xo = "[href]", To = ".nav-link", So = `${To}, .nav-item > ${To}, .list-group-item`, ko = { offset: null, rootMargin: "0px 0px -25%", smoothScroll: !1, target: null, threshold: [.1, .5, 1] }, Oo = { offset: "(number|null)", rootMargin: "string", smoothScroll: "boolean", target: "element", threshold: "array" }; class Lo extends ve { constructor(t, e) { super(t, e), this._targetLinks = new Map, this._observableSections = new Map, this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }, this.refresh() } static get Default() { return ko } static get DefaultType() { return Oo } static get NAME() { return "scrollspy" } refresh() { this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver(); for (const t of this._observableSections.values()) this._observer.observe(t) } dispose() { this._observer.disconnect(), super.dispose() } _configAfterMerge(t) { return t.target = Ft(t.target) || document.body, t.rootMargin = t.offset ? `${t.offset}px 0px -30%` : t.rootMargin, "string" == typeof t.threshold && (t.threshold = t.threshold.split(",").map((t => Number.parseFloat(t)))), t } _maybeEnableSmoothScroll() { this._config.smoothScroll && (fe.off(this._config.target, Eo), fe.on(this._config.target, Eo, xo, (t => { const e = this._observableSections.get(t.target.hash); if (e) { t.preventDefault(); const n = this._rootElement || window, i = e.offsetTop - this._element.offsetTop; if (n.scrollTo) return void n.scrollTo({ top: i, behavior: "smooth" }); n.scrollTop = i } }))) } _getNewObserver() { const t = { root: this._rootElement, threshold: this._config.threshold, rootMargin: this._config.rootMargin }; return new IntersectionObserver((t => this._observerCallback(t)), t) } _observerCallback(t) { const e = t => this._targetLinks.get(`#${t.target.id}`), n = t => { this._previousScrollData.visibleEntryTop = t.target.offsetTop, this._process(e(t)) }, i = (this._rootElement || document.documentElement).scrollTop, o = i >= this._previousScrollData.parentScrollTop; this._previousScrollData.parentScrollTop = i; for (const r of t) { if (!r.isIntersecting) { this._activeTarget = null, this._clearActiveClass(e(r)); continue } const t = r.target.offsetTop >= this._previousScrollData.visibleEntryTop; if (o && t) { if (n(r), !i) return } else o || t || n(r) } } _initializeTargetsAndObservables() { this._targetLinks = new Map, this._observableSections = new Map; const t = ye.find(xo, this._config.target); for (const e of t) { if (!e.hash || Ht(e)) continue; const t = ye.findOne(decodeURI(e.hash), this._element); zt(t) && (this._targetLinks.set(decodeURI(e.hash), e), this._observableSections.set(e.hash, t)) } } _process(t) { this._activeTarget !== t && (this._clearActiveClass(this._config.target), this._activeTarget = t, t.classList.add(Co), this._activateParents(t), fe.trigger(this._element, wo, { relatedTarget: t })) } _activateParents(t) { if (t.classList.contains("dropdown-item")) ye.findOne(".dropdown-toggle", t.closest(".dropdown")).classList.add(Co); else for (const e of ye.parents(t, ".nav, .list-group")) for (const t of ye.prev(e, So)) t.classList.add(Co) } _clearActiveClass(t) { t.classList.remove(Co); const e = ye.find(`${xo}.${Co}`, t); for (const t of e) t.classList.remove(Co) } static jQueryInterface(t) { return this.each((function () { const e = Lo.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`); e[t]() } })) } } fe.on(window, Ao, (() => { for (const t of ye.find('[data-bs-spy="scroll"]')) Lo.getOrCreateInstance(t) })), Kt(Lo); const Do = ".bs.tab", Po = `hide${Do}`, Io = `hidden${Do}`, Mo = `show${Do}`, No = `shown${Do}`, $o = `click${Do}`, jo = `keydown${Do}`, Fo = `load${Do}`, zo = "ArrowLeft", Ho = "ArrowRight", Wo = "ArrowUp", qo = "ArrowDown", Bo = "Home", Ro = "End", Vo = "active", Xo = "fade", Ko = "show", Uo = ".dropdown-toggle", Yo = `:not(${Uo})`, Qo = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', Go = `.nav-link${Yo}, .list-group-item${Yo}, [role="tab"]${Yo}, ${Qo}`, Jo = `.${Vo}[data-bs-toggle="tab"], .${Vo}[data-bs-toggle="pill"], .${Vo}[data-bs-toggle="list"]`; class Zo extends ve { constructor(t) { super(t), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), fe.on(this._element, jo, (t => this._keydown(t)))) } static get NAME() { return "tab" } show() { const t = this._element; if (this._elemIsActive(t)) return; const e = this._getActiveElem(), n = e ? fe.trigger(e, Po, { relatedTarget: t }) : null; fe.trigger(t, Mo, { relatedTarget: e }).defaultPrevented || n && n.defaultPrevented || (this._deactivate(e, t), this._activate(t, e)) } _activate(t, e) { t && (t.classList.add(Vo), this._activate(ye.getElementFromSelector(t)), this._queueCallback((() => { "tab" === t.getAttribute("role") ? (t.removeAttribute("tabindex"), t.setAttribute("aria-selected", !0), this._toggleDropDown(t, !0), fe.trigger(t, No, { relatedTarget: e })) : t.classList.add(Ko) }), t, t.classList.contains(Xo))) } _deactivate(t, e) { t && (t.classList.remove(Vo), t.blur(), this._deactivate(ye.getElementFromSelector(t)), this._queueCallback((() => { "tab" === t.getAttribute("role") ? (t.setAttribute("aria-selected", !1), t.setAttribute("tabindex", "-1"), this._toggleDropDown(t, !1), fe.trigger(t, Io, { relatedTarget: e })) : t.classList.remove(Ko) }), t, t.classList.contains(Xo))) } _keydown(t) { if (![zo, Ho, Wo, qo, Bo, Ro].includes(t.key)) return; t.stopPropagation(), t.preventDefault(); const e = this._getChildren().filter((t => !Ht(t))); let n; if ([Bo, Ro].includes(t.key)) n = e[t.key === Bo ? 0 : e.length - 1]; else { const i = [Ho, qo].includes(t.key); n = Qt(e, t.target, i, !0) } n && (n.focus({ preventScroll: !0 }), Zo.getOrCreateInstance(n).show()) } _getChildren() { return ye.find(Go, this._parent) } _getActiveElem() { return this._getChildren().find((t => this._elemIsActive(t))) || null } _setInitialAttributes(t, e) { this._setAttributeIfNotExists(t, "role", "tablist"); for (const t of e) this._setInitialAttributesOnChild(t) } _setInitialAttributesOnChild(t) { t = this._getInnerElement(t); const e = this._elemIsActive(t), n = this._getOuterElement(t); t.setAttribute("aria-selected", e), n !== t && this._setAttributeIfNotExists(n, "role", "presentation"), e || t.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(t, "role", "tab"), this._setInitialAttributesOnTargetPanel(t) } _setInitialAttributesOnTargetPanel(t) { const e = ye.getElementFromSelector(t); e && (this._setAttributeIfNotExists(e, "role", "tabpanel"), t.id && this._setAttributeIfNotExists(e, "aria-labelledby", `${t.id}`)) } _toggleDropDown(t, e) { const n = this._getOuterElement(t); if (!n.classList.contains("dropdown")) return; const i = (t, i) => { const o = ye.findOne(t, n); o && o.classList.toggle(i, e) }; i(Uo, Vo), i(".dropdown-menu", Ko), n.setAttribute("aria-expanded", e) } _setAttributeIfNotExists(t, e, n) { t.hasAttribute(e) || t.setAttribute(e, n) } _elemIsActive(t) { return t.classList.contains(Vo) } _getInnerElement(t) { return t.matches(Go) ? t : ye.findOne(Go, t) } _getOuterElement(t) { return t.closest(".nav-item, .list-group-item") || t } static jQueryInterface(t) { return this.each((function () { const e = Zo.getOrCreateInstance(this); if ("string" == typeof t) { if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`); e[t]() } })) } } fe.on(document, $o, Qo, (function (t) { ["A", "AREA"].includes(this.tagName) && t.preventDefault(), Ht(this) || Zo.getOrCreateInstance(this).show() })), fe.on(window, Fo, (() => { for (const t of ye.find(Jo)) Zo.getOrCreateInstance(t) })), Kt(Zo); const tr = ".bs.toast", er = `mouseover${tr}`, nr = `mouseout${tr}`, ir = `focusin${tr}`, or = `focusout${tr}`, rr = `hide${tr}`, sr = `hidden${tr}`, ar = `show${tr}`, cr = `shown${tr}`, lr = "hide", ur = "show", dr = "showing", fr = { animation: "boolean", autohide: "boolean", delay: "number" }, hr = { animation: !0, autohide: !0, delay: 5e3 }; class pr extends ve { constructor(t, e) { super(t, e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners() } static get Default() { return hr } static get DefaultType() { return fr } static get NAME() { return "toast" } show() { fe.trigger(this._element, ar).defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove(lr), Bt(this._element), this._element.classList.add(ur, dr), this._queueCallback((() => { this._element.classList.remove(dr), fe.trigger(this._element, cr), this._maybeScheduleHide() }), this._element, this._config.animation)) } hide() { this.isShown() && (fe.trigger(this._element, rr).defaultPrevented || (this._element.classList.add(dr), this._queueCallback((() => { this._element.classList.add(lr), this._element.classList.remove(dr, ur), fe.trigger(this._element, sr) }), this._element, this._config.animation))) } dispose() { this._clearTimeout(), this.isShown() && this._element.classList.remove(ur), super.dispose() } isShown() { return this._element.classList.contains(ur) } _maybeScheduleHide() { this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout((() => { this.hide() }), this._config.delay))) } _onInteraction(t, e) { switch (t.type) { case "mouseover": case "mouseout": this._hasMouseInteraction = e; break; case "focusin": case "focusout": this._hasKeyboardInteraction = e }if (e) return void this._clearTimeout(); const n = t.relatedTarget; this._element === n || this._element.contains(n) || this._maybeScheduleHide() } _setListeners() { fe.on(this._element, er, (t => this._onInteraction(t, !0))), fe.on(this._element, nr, (t => this._onInteraction(t, !1))), fe.on(this._element, ir, (t => this._onInteraction(t, !0))), fe.on(this._element, or, (t => this._onInteraction(t, !1))) } _clearTimeout() { clearTimeout(this._timeout), this._timeout = null } static jQueryInterface(t) { return this.each((function () { const e = pr.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t](this) } })) } } function gr() { document.querySelectorAll(".check-overflow").forEach((function (t) { var e = t.firstElementChild; e && e.scrollHeight > t.clientHeight + 5 ? (t.classList.add("is-overflowing"), t.dataset.listenerAdded || (t.dataset.listenerAdded = "true", t.addEventListener("click", (function () { t.classList.toggle("show-overflow") })))) : (t.classList.remove("is-overflowing"), t.classList.remove("show-overflow")) })) } function mr(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } we(pr), Kt(pr); var _r = "(prefers-reduced-motion: reduce)", vr = { CREATED: 1, MOUNTED: 2, IDLE: 3, MOVING: 4, SCROLLING: 5, DRAGGING: 6, DESTROYED: 7 }; function br(t) { t.length = 0 } function yr(t, e, n) { return Array.prototype.slice.call(t, e, n) } function wr(t) { return t.bind.apply(t, [null].concat(yr(arguments, 1))) } var Er = setTimeout, Ar = function () { }; function Cr(t) { return requestAnimationFrame(t) } function xr(t, e) { return typeof e === t } function Tr(t) { return !Dr(t) && xr("object", t) } var Sr = Array.isArray, kr = wr(xr, "function"), Or = wr(xr, "string"), Lr = wr(xr, "undefined"); function Dr(t) { return null === t } function Pr(t) { try { return t instanceof (t.ownerDocument.defaultView || window).HTMLElement } catch (t) { return !1 } } function Ir(t) { return Sr(t) ? t : [t] } function Mr(t, e) { Ir(t).forEach(e) } function Nr(t, e) { return t.indexOf(e) > -1 } function $r(t, e) { return t.push.apply(t, Ir(e)), t } function jr(t, e, n) { t && Mr(e, (function (e) { e && t.classList[n ? "add" : "remove"](e) })) } function Fr(t, e) { jr(t, Or(e) ? e.split(" ") : e, !0) } function zr(t, e) { Mr(e, t.appendChild.bind(t)) } function Hr(t, e) { Mr(t, (function (t) { var n = (e || t).parentNode; n && n.insertBefore(t, e) })) } function Wr(t, e) { return Pr(t) && (t.msMatchesSelector || t.matches).call(t, e) } function qr(t, e) { var n = t ? yr(t.children) : []; return e ? n.filter((function (t) { return Wr(t, e) })) : n } function Br(t, e) { return e ? qr(t, e)[0] : t.firstElementChild } var Rr = Object.keys; function Vr(t, e, n) { return t && (n ? Rr(t).reverse() : Rr(t)).forEach((function (n) { "__proto__" !== n && e(t[n], n) })), t } function Xr(t) { return yr(arguments, 1).forEach((function (e) { Vr(e, (function (n, i) { t[i] = e[i] })) })), t } function Kr(t) { return yr(arguments, 1).forEach((function (e) { Vr(e, (function (e, n) { Sr(e) ? t[n] = e.slice() : Tr(e) ? t[n] = Kr({}, Tr(t[n]) ? t[n] : {}, e) : t[n] = e })) })), t } function Ur(t, e) { Mr(e || Rr(t), (function (e) { delete t[e] })) } function Yr(t, e) { Mr(t, (function (t) { Mr(e, (function (e) { t && t.removeAttribute(e) })) })) } function Qr(t, e, n) { Tr(e) ? Vr(e, (function (e, n) { Qr(t, n, e) })) : Mr(t, (function (t) { Dr(n) || "" === n ? Yr(t, e) : t.setAttribute(e, String(n)) })) } function Gr(t, e, n) { var i = document.createElement(t); return e && (Or(e) ? Fr(i, e) : Qr(i, e)), n && zr(n, i), i } function Jr(t, e, n) { if (Lr(n)) return getComputedStyle(t)[e]; Dr(n) || (t.style[e] = "" + n) } function Zr(t, e) { Jr(t, "display", e) } function ts(t) { t.setActive && t.setActive() || t.focus({ preventScroll: !0 }) } function es(t, e) { return t.getAttribute(e) } function ns(t, e) { return t && t.classList.contains(e) } function is(t) { return t.getBoundingClientRect() } function os(t) { Mr(t, (function (t) { t && t.parentNode && t.parentNode.removeChild(t) })) } function rs(t) { return Br((new DOMParser).parseFromString(t, "text/html").body) } function ss(t, e) { t.preventDefault(), e && (t.stopPropagation(), t.stopImmediatePropagation()) } function as(t, e) { return t && t.querySelector(e) } function cs(t, e) { return e ? yr(t.querySelectorAll(e)) : [] } function ls(t, e) { jr(t, e, !1) } function us(t) { return t.timeStamp } function ds(t) { return Or(t) ? t : t ? t + "px" : "" } var fs = "splide", hs = "data-" + fs; function ps(t, e) { if (!t) throw new Error("[" + fs + "] " + (e || "")) } var gs = Math.min, ms = Math.max, _s = Math.floor, vs = Math.ceil, bs = Math.abs; function ys(t, e, n) { return bs(t - e) < n } function ws(t, e, n, i) { var o = gs(e, n), r = ms(e, n); return i ? o < t && t < r : o <= t && t <= r } function Es(t, e, n) { var i = gs(e, n), o = ms(e, n); return gs(ms(i, t), o) } function As(t) { return +(t > 0) - +(t < 0) } function Cs(t, e) { return Mr(e, (function (e) { t = t.replace("%s", "" + e) })), t } function xs(t) { return t < 10 ? "0" + t : "" + t } var Ts = {}; function Ss() { var t = []; function e(t, e, n) { Mr(t, (function (t) { t && Mr(e, (function (e) { e.split(" ").forEach((function (e) { var i = e.split("."); n(t, i[0], i[1]) })) })) })) } return { bind: function (n, i, o, r) { e(n, i, (function (e, n, i) { var s = "addEventListener" in e, a = s ? e.removeEventListener.bind(e, n, o, r) : e.removeListener.bind(e, o); s ? e.addEventListener(n, o, r) : e.addListener(o), t.push([e, n, i, o, a]) })) }, unbind: function (n, i, o) { e(n, i, (function (e, n, i) { t = t.filter((function (t) { return !!(t[0] !== e || t[1] !== n || t[2] !== i || o && t[3] !== o) || (t[4](), !1) })) })) }, dispatch: function (t, e, n) { var i, o = !0; return "function" == typeof CustomEvent ? i = new CustomEvent(e, { bubbles: o, detail: n }) : (i = document.createEvent("CustomEvent")).initCustomEvent(e, o, !1, n), t.dispatchEvent(i), i }, destroy: function () { t.forEach((function (t) { t[4]() })), br(t) } } } var ks = "mounted", Os = "ready", Ls = "move", Ds = "moved", Ps = "click", Is = "refresh", Ms = "updated", Ns = "resize", $s = "resized", js = "scroll", Fs = "scrolled", zs = "destroy", Hs = "navigation:mounted", Ws = "autoplay:play", qs = "autoplay:pause", Bs = "lazyload:loaded", Rs = "ei"; function Vs(t) { var e = t ? t.event.bus : document.createDocumentFragment(), n = Ss(); return t && t.event.on(zs, n.destroy), Xr(n, { bus: e, on: function (t, i) { n.bind(e, Ir(t).join(" "), (function (t) { i.apply(i, Sr(t.detail) ? t.detail : []) })) }, off: wr(n.unbind, e), emit: function (t) { n.dispatch(e, t, yr(arguments, 1)) } }) } function Xs(t, e, n, i) { var o, r, s = Date.now, a = 0, c = !0, l = 0; function u() { if (!c) { if (a = t ? gs((s() - o) / t, 1) : 1, n && n(a), a >= 1 && (e(), o = s(), i && ++l >= i)) return d(); r = Cr(u) } } function d() { c = !0 } function f() { r && cancelAnimationFrame(r), a = 0, r = 0, c = !0 } return { start: function (e) { e || f(), o = s() - (e ? a * t : 0), c = !1, r = Cr(u) }, rewind: function () { o = s(), a = 0, n && n(a) }, pause: d, cancel: f, set: function (e) { t = e }, isPaused: function () { return c } } } var Ks = "Arrow", Us = Ks + "Left", Ys = Ks + "Right", Qs = Ks + "Up", Gs = Ks + "Down", Js = "ttb", Zs = { width: ["height"], left: ["top", "right"], right: ["bottom", "left"], x: ["y"], X: ["Y"], Y: ["X"], ArrowLeft: [Qs, Ys], ArrowRight: [Gs, Us] }; var ta = "role", ea = "tabindex", na = "aria-", ia = na + "controls", oa = na + "current", ra = na + "selected", sa = na + "label", aa = na + "labelledby", ca = na + "hidden", la = na + "orientation", ua = na + "roledescription", da = na + "live", fa = na + "busy", ha = na + "atomic", pa = [ta, ea, "disabled", ia, oa, sa, aa, ca, la, ua], ga = fs + "__", ma = "is-", _a = fs, va = ga + "track", ba = ga + "list", ya = ga + "slide", wa = ya + "--clone", Ea = ya + "__container", Aa = ga + "arrows", Ca = ga + "arrow", xa = Ca + "--prev", Ta = Ca + "--next", Sa = ga + "pagination", ka = Sa + "__page", Oa = ga + "progress__bar", La = ga + "toggle", Da = ga + "sr", Pa = ma + "initialized", Ia = ma + "active", Ma = ma + "prev", Na = ma + "next", $a = ma + "visible", ja = ma + "loading", Fa = ma + "focus-in", za = ma + "overflow", Ha = [Ia, $a, Ma, Na, ja, Fa, za], Wa = { slide: ya, clone: wa, arrows: Aa, arrow: Ca, prev: xa, next: Ta, pagination: Sa, page: ka, spinner: ga + "spinner" }, qa = "touchstart mousedown", Ba = "touchmove mousemove", Ra = "touchend touchcancel mouseup click", Va = "slide", Xa = "loop", Ka = "fade"; var Ua = hs + "-interval", Ya = { passive: !1, capture: !0 }, Qa = { Spacebar: " ", Right: Ys, Left: Us, Up: Qs, Down: Gs }; function Ga(t) { return t = Or(t) ? t : t.key, Qa[t] || t } var Ja = "keydown", Za = hs + "-lazy", tc = Za + "-srcset", ec = "[" + Za + "], [" + tc + "]", nc = [" ", "Enter"], ic = Object.freeze({ __proto__: null, Media: function (t, e, n) { var i = t.state, o = n.breakpoints || {}, r = n.reducedMotion || {}, s = Ss(), a = []; function c(t) { t && s.destroy() } function l(t, e) { var n = matchMedia(e); s.bind(n, "change", u), a.push([t, n]) } function u() { var e = i.is(7), o = n.direction, r = a.reduce((function (t, e) { return Kr(t, e[1].matches ? e[0] : {}) }), {}); Ur(n), d(r), n.destroy ? t.destroy("completely" === n.destroy) : e ? (c(!0), t.mount()) : o !== n.direction && t.refresh() } function d(e, o, r) { Kr(n, e), o && Kr(Object.getPrototypeOf(n), e), !r && i.is(1) || t.emit(Ms, n) } return { setup: function () { var t = "min" === n.mediaQuery; Rr(o).sort((function (e, n) { return t ? +e - +n : +n - +e })).forEach((function (e) { l(o[e], "(" + (t ? "min" : "max") + "-width:" + e + "px)") })), l(r, _r), u() }, destroy: c, reduce: function (t) { matchMedia(_r).matches && (t ? Kr(n, r) : Ur(n, Rr(r))) }, set: d } }, Direction: function (t, e, n) { return { resolve: function (t, e, i) { var o = "rtl" !== (i = i || n.direction) || e ? i === Js ? 0 : -1 : 1; return Zs[t] && Zs[t][o] || t.replace(/width|left|right/i, (function (t, e) { var n = Zs[t.toLowerCase()][o] || t; return e > 0 ? n.charAt(0).toUpperCase() + n.slice(1) : n })) }, orient: function (t) { return t * ("rtl" === n.direction ? 1 : -1) } } }, Elements: function (t, e, n) { var i, o, r, s = Vs(t), a = s.on, c = s.bind, l = t.root, u = n.i18n, d = {}, f = [], h = [], p = []; function g() { var t, e, r; i = v("." + va), o = Br(i, "." + ba), ps(i && o, "A track/list element is missing."), $r(f, qr(o, "." + ya + ":not(." + wa + ")")), Vr({ arrows: Aa, pagination: Sa, prev: xa, next: Ta, bar: Oa, toggle: La }, (function (t, e) { d[e] = v("." + t) })), Xr(d, { root: l, track: i, list: o, slides: f }), e = l.id || "" + (t = fs) + xs(Ts[t] = (Ts[t] || 0) + 1), r = n.role, l.id = e, i.id = i.id || e + "-track", o.id = o.id || e + "-list", !es(l, ta) && "SECTION" !== l.tagName && r && Qr(l, ta, r), Qr(l, ua, u.carousel), Qr(o, ta, "presentation"), _() } function m(t) { var e = pa.concat("style"); br(f), ls(l, h), ls(i, p), Yr([i, o], e), Yr(l, t ? e : ["style", ua]) } function _() { ls(l, h), ls(i, p), h = b(_a), p = b(va), Fr(l, h), Fr(i, p), Qr(l, sa, n.label), Qr(l, aa, n.labelledby) } function v(t) { var e = as(l, t); return e && function (t, e) { if (kr(t.closest)) return t.closest(e); for (var n = t; n && 1 === n.nodeType && !Wr(n, e);)n = n.parentElement; return n }(e, "." + _a) === l ? e : void 0 } function b(t) { return [t + "--" + n.type, t + "--" + n.direction, n.drag && t + "--draggable", n.isNavigation && t + "--nav", t === _a && Ia] } return Xr(d, { setup: g, mount: function () { a(Is, m), a(Is, g), a(Ms, _), c(document, qa + " keydown", (function (t) { r = "keydown" === t.type }), { capture: !0 }), c(l, "focusin", (function () { jr(l, Fa, !!r) })) }, destroy: m }) }, Slides: function (t, e, n) { var i = Vs(t), o = i.on, r = i.emit, s = i.bind, a = e.Elements, c = a.slides, l = a.list, u = []; function d() { c.forEach((function (t, e) { h(t, e, -1) })) } function f() { g((function (t) { t.destroy() })), br(u) } function h(e, n, i) { var o = function (t, e, n, i) { var o, r = Vs(t), s = r.on, a = r.emit, c = r.bind, l = t.Components, u = t.root, d = t.options, f = d.isNavigation, h = d.updateOnMove, p = d.i18n, g = d.pagination, m = d.slideFocus, _ = l.Direction.resolve, v = es(i, "style"), b = es(i, sa), y = n > -1, w = Br(i, "." + Ea); function E() { var o = t.splides.map((function (t) { var n = t.splide.Components.Slides.getAt(e); return n ? n.slide.id : "" })).join(" "); Qr(i, sa, Cs(p.slideX, (y ? n : e) + 1)), Qr(i, ia, o), Qr(i, ta, m ? "button" : ""), m && Yr(i, ua) } function A() { o || C() } function C() { if (!o) { var n = t.index; (r = x()) !== ns(i, Ia) && (jr(i, Ia, r), Qr(i, oa, f && r || ""), a(r ? "active" : "inactive", T)), function () { var e = function () { if (t.is(Ka)) return x(); var e = is(l.Elements.track), n = is(i), o = _("left", !0), r = _("right", !0); return _s(e[o]) <= vs(n[o]) && _s(n[r]) <= vs(e[r]) }(), n = !e && (!x() || y); if (t.state.is([4, 5]) || Qr(i, ca, n || ""), Qr(cs(i, d.focusableNodes || ""), ea, n ? -1 : ""), m && Qr(i, ea, n ? -1 : 0), e !== ns(i, $a) && (jr(i, $a, e), a(e ? "visible" : "hidden", T)), !e && document.activeElement === i) { var o = l.Slides.getAt(t.index); o && ts(o.slide) } }(), jr(i, Ma, e === n - 1), jr(i, Na, e === n + 1) } var r } function x() { var i = t.index; return i === e || d.cloneStatus && i === n } var T = { index: e, slideIndex: n, slide: i, container: w, isClone: y, mount: function () { y || (i.id = u.id + "-slide" + xs(e + 1), Qr(i, ta, g ? "tabpanel" : "group"), Qr(i, ua, p.slide), Qr(i, sa, b || Cs(p.slideLabel, [e + 1, t.length]))), c(i, "click", wr(a, Ps, T)), c(i, "keydown", wr(a, "sk", T)), s([Ds, "sh", Fs], C), s(Hs, E), h && s(Ls, A) }, destroy: function () { o = !0, r.destroy(), ls(i, Ha), Yr(i, pa), Qr(i, "style", v), Qr(i, sa, b || "") }, update: C, style: function (t, e, n) { Jr(n && w || i, t, e) }, isWithin: function (n, i) { var o = bs(n - e); return y || !d.rewind && !t.is(Xa) || (o = gs(o, t.length - o)), o <= i } }; return T }(t, n, i, e); o.mount(), u.push(o), u.sort((function (t, e) { return t.index - e.index })) } function p(t) { return t ? m((function (t) { return !t.isClone })) : u } function g(t, e) { p(e).forEach(t) } function m(t) { return u.filter(kr(t) ? t : function (e) { return Or(t) ? Wr(e.slide, t) : Nr(Ir(t), e.index) }) } return { mount: function () { d(), o(Is, f), o(Is, d) }, destroy: f, update: function () { g((function (t) { t.update() })) }, register: h, get: p, getIn: function (t) { var i = e.Controller, o = i.toIndex(t), r = i.hasFocus() ? 1 : n.perPage; return m((function (t) { return ws(t.index, o, o + r - 1) })) }, getAt: function (t) { return m(t)[0] }, add: function (t, e) { Mr(t, (function (t) { if (Or(t) && (t = rs(t)), Pr(t)) { var i = c[e]; i ? Hr(t, i) : zr(l, t), Fr(t, n.classes.slide), o = t, a = wr(r, Ns), u = cs(o, "img"), (d = u.length) ? u.forEach((function (t) { s(t, "load error", (function () { --d || a() })) })) : a() } var o, a, u, d })), r(Is) }, remove: function (t) { os(m(t).map((function (t) { return t.slide }))), r(Is) }, forEach: g, filter: m, style: function (t, e, n) { g((function (i) { i.style(t, e, n) })) }, getLength: function (t) { return t ? c.length : u.length }, isEnough: function () { return u.length > n.perPage } } }, Layout: function (t, e, n) { var i, o, r, s = Vs(t), a = s.on, c = s.bind, l = s.emit, u = e.Slides, d = e.Direction.resolve, f = e.Elements, h = f.root, p = f.track, g = f.list, m = u.getAt, _ = u.style; function v() { i = n.direction === Js, Jr(h, "maxWidth", ds(n.width)), Jr(p, d("paddingLeft"), y(!1)), Jr(p, d("paddingRight"), y(!0)), b(!0) } function b(t) { var e, s = is(h); (t || o.width !== s.width || o.height !== s.height) && (Jr(p, "height", (e = "", i && (ps(e = w(), "height or heightRatio is missing."), e = "calc(" + e + " - " + y(!1) + " - " + y(!0) + ")"), e)), _(d("marginRight"), ds(n.gap)), _("width", n.autoWidth ? null : ds(n.fixedWidth) || (i ? "" : E())), _("height", ds(n.fixedHeight) || (i ? n.autoHeight ? null : E() : w()), !0), o = s, l($s), r !== (r = k()) && (jr(h, za, r), l("overflow", r))) } function y(t) { var e = n.padding, i = d(t ? "right" : "left"); return e && ds(e[i] || (Tr(e) ? 0 : e)) || "0px" } function w() { return ds(n.height || is(g).width * n.heightRatio) } function E() { var t = ds(n.gap); return "calc((100%" + (t && " + " + t) + ")/" + (n.perPage || 1) + (t && " - " + t) + ")" } function A() { return is(g)[d("width")] } function C(t, e) { var n = m(t || 0); return n ? is(n.slide)[d("width")] + (e ? 0 : S()) : 0 } function x(t, e) { var n = m(t); if (n) { var i = is(n.slide)[d("right")], o = is(g)[d("left")]; return bs(i - o) + (e ? 0 : S()) } return 0 } function T(e) { return x(t.length - 1) - x(0) + C(0, e) } function S() { var t = m(0); return t && parseFloat(Jr(t.slide, d("marginRight"))) || 0 } function k() { return t.is(Ka) || T(!0) > A() } return { mount: function () { var t, e; v(), c(window, "resize load", (t = wr(l, Ns), e = Xs(0, t, null, 1), function () { e.isPaused() && e.start() })), a([Ms, Is], v), a(Ns, b) }, resize: b, listSize: A, slideSize: C, sliderSize: T, totalSize: x, getPadding: function (t) { return parseFloat(Jr(p, d("padding" + (t ? "Right" : "Left")))) || 0 }, isOverflow: k } }, Clones: function (t, e, n) { var i, o = Vs(t), r = o.on, s = e.Elements, a = e.Slides, c = e.Direction.resolve, l = []; function u() { r(Is, d), r([Ms, Ns], h), (i = p()) && (function (e) { var i = a.get().slice(), o = i.length; if (o) { for (; i.length < e;)$r(i, i); $r(i.slice(-e), i.slice(0, e)).forEach((function (r, c) { var u = c < e, d = function (e, i) { var o = e.cloneNode(!0); return Fr(o, n.classes.clone), o.id = t.root.id + "-clone" + xs(i + 1), o }(r.slide, c); u ? Hr(d, i[0].slide) : zr(s.list, d), $r(l, d), a.register(d, c - e + (u ? 0 : o), r.index) })) } }(i), e.Layout.resize(!0)) } function d() { f(), u() } function f() { os(l), br(l), o.destroy() } function h() { var t = p(); i !== t && (i < t || !t) && o.emit(Is) } function p() { var i = n.clones; if (t.is(Xa)) { if (Lr(i)) { var o = n[c("fixedWidth")] && e.Layout.slideSize(0); i = o && vs(is(s.track)[c("width")] / o) || n[c("autoWidth")] && t.length || 2 * n.perPage } } else i = 0; return i } return { mount: u, destroy: f } }, Move: function (t, e, n) { var i, o = Vs(t), r = o.on, s = o.emit, a = t.state.set, c = e.Layout, l = c.slideSize, u = c.getPadding, d = c.totalSize, f = c.listSize, h = c.sliderSize, p = e.Direction, g = p.resolve, m = p.orient, _ = e.Elements, v = _.list, b = _.track; function y() { e.Controller.isBusy() || (e.Scroll.cancel(), w(t.index), e.Slides.update()) } function w(t) { E(T(t, !0)) } function E(n, i) { if (!t.is(Ka)) { var o = i ? n : function (n) { if (t.is(Xa)) { var i = x(n), o = i > e.Controller.getEnd(); (i < 0 || o) && (n = A(n, o)) } return n }(n); Jr(v, "transform", "translate" + g("X") + "(" + o + "px)"), n !== o && s("sh") } } function A(t, e) { var n = t - k(e), i = h(); return t - m(i * (vs(bs(n) / i) || 1)) * (e ? 1 : -1) } function C() { E(S(), !0), i.cancel() } function x(t) { for (var n = e.Slides.get(), i = 0, o = 1 / 0, r = 0; r < n.length; r++) { var s = n[r].index, a = bs(T(s, !0) - t); if (!(a <= o)) break; o = a, i = s } return i } function T(e, i) { var o = m(d(e - 1) - function (t) { var e = n.focus; return "center" === e ? (f() - l(t, !0)) / 2 : +e * l(t) || 0 }(e)); return i ? function (e) { return n.trimSpace && t.is(Va) && (e = Es(e, 0, m(h(!0) - f()))), e }(o) : o } function S() { var t = g("left"); return is(v)[t] - is(b)[t] + m(u(!1)) } function k(t) { return T(t ? e.Controller.getEnd() : 0, !!n.trimSpace) } return { mount: function () { i = e.Transition, r([ks, $s, Ms, Is], y) }, move: function (t, e, n, o) { var r, c; t !== e && (r = t > n, c = m(A(S(), r)), r ? c >= 0 : c <= v[g("scrollWidth")] - is(b)[g("width")]) && (C(), E(A(S(), t > n), !0)), a(4), s(Ls, e, n, t), i.start(e, (function () { a(3), s(Ds, e, n, t), o && o() })) }, jump: w, translate: E, shift: A, cancel: C, toIndex: x, toPosition: T, getPosition: S, getLimit: k, exceededLimit: function (t, e) { e = Lr(e) ? S() : e; var n = !0 !== t && m(e) < m(k(!1)), i = !1 !== t && m(e) > m(k(!0)); return n || i }, reposition: y } }, Controller: function (t, e, n) { var i, o, r, s, a = Vs(t), c = a.on, l = a.emit, u = e.Move, d = u.getPosition, f = u.getLimit, h = u.toPosition, p = e.Slides, g = p.isEnough, m = p.getLength, _ = n.omitEnd, v = t.is(Xa), b = t.is(Va), y = wr(T, !1), w = wr(T, !0), E = n.start || 0, A = E; function C() { o = m(!0), r = n.perMove, s = n.perPage, i = O(); var t = Es(E, 0, _ ? i : o - 1); t !== E && (E = t, u.reposition()) } function x() { i !== O() && l(Rs) } function T(t, e) { var n = r || (I() ? 1 : s), o = S(E + n * (t ? -1 : 1), E, !(r || I())); return -1 === o && b && !ys(d(), f(!t), 1) ? t ? 0 : i : e ? o : k(o) } function S(e, a, c) { if (g() || I()) { var l = function (e) { if (b && "move" === n.trimSpace && e !== E) for (var i = d(); i === h(e, !0) && ws(e, 0, t.length - 1, !n.rewind);)e < E ? --e : ++e; return e }(e); l !== e && (a = e, e = l, c = !1), e < 0 || e > i ? e = r || !ws(0, e, a, !0) && !ws(i, a, e, !0) ? v ? c ? e < 0 ? -(o % s || s) : o : e : n.rewind ? e < 0 ? i : 0 : -1 : L(D(e)) : c && e !== a && (e = L(D(a) + (e < a ? -1 : 1))) } else e = -1; return e } function k(t) { return v ? (t + o) % o || 0 : t } function O() { for (var t = o - (I() || v && r ? 1 : s); _ && t-- > 0;)if (h(o - 1, !0) !== h(t, !0)) { t++; break } return Es(t, 0, o - 1) } function L(t) { return Es(I() ? t : s * t, 0, i) } function D(t) { return I() ? gs(t, i) : _s((t >= i ? o - 1 : t) / s) } function P(t) { t !== E && (A = E, E = t) } function I() { return !Lr(n.focus) || n.isNavigation } function M() { return t.state.is([4, 5]) && !!n.waitForTransition } return { mount: function () { C(), c([Ms, Is, Rs], C), c($s, x) }, go: function (t, e, n) { if (!M()) { var o = function (t) { var e = E; if (Or(t)) { var n = t.match(/([+\-<>])(\d+)?/) || [], o = n[1], r = n[2]; "+" === o || "-" === o ? e = S(E + +("" + o + (+r || 1)), E) : ">" === o ? e = r ? L(+r) : y(!0) : "<" === o && (e = w(!0)) } else e = v ? t : Es(t, 0, i); return e }(t), r = k(o); r > -1 && (e || r !== E) && (P(r), u.move(o, r, A, n)) } }, scroll: function (t, n, o, r) { e.Scroll.scroll(t, n, o, (function () { var t = k(u.toIndex(d())); P(_ ? gs(t, i) : t), r && r() })) }, getNext: y, getPrev: w, getAdjacent: T, getEnd: O, setIndex: P, getIndex: function (t) { return t ? A : E }, toIndex: L, toPage: D, toDest: function (t) { var e = u.toIndex(t); return b ? Es(e, 0, i) : e }, hasFocus: I, isBusy: M } }, Arrows: function (t, e, n) { var i, o, r = Vs(t), s = r.on, a = r.bind, c = r.emit, l = n.classes, u = n.i18n, d = e.Elements, f = e.Controller, h = d.arrows, p = d.track, g = h, m = d.prev, _ = d.next, v = {}; function b() { var t; !(t = n.arrows) || m && _ || (g = h || Gr("div", l.arrows), m = A(!0), _ = A(!1), i = !0, zr(g, [m, _]), !h && Hr(g, p)), m && _ && (Xr(v, { prev: m, next: _ }), Zr(g, t ? "" : "none"), Fr(g, o = Aa + "--" + n.direction), t && (s([ks, Ds, Is, Fs, Rs], C), a(_, "click", wr(E, ">")), a(m, "click", wr(E, "<")), C(), Qr([m, _], ia, p.id), c("arrows:mounted", m, _))), s(Ms, y) } function y() { w(), b() } function w() { r.destroy(), ls(g, o), i ? (os(h ? [m, _] : g), m = _ = null) : Yr([m, _], pa) } function E(t) { f.go(t, !0) } function A(t) { return rs('<button class="' + l.arrow + " " + (t ? l.prev : l.next) + '" type="button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40" width="40" height="40" focusable="false"><path d="' + (n.arrowPath || "m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z") + '" />') } function C() { if (m && _) { var e = t.index, n = f.getPrev(), i = f.getNext(), o = n > -1 && e < n ? u.last : u.prev, r = i > -1 && e > i ? u.first : u.next; m.disabled = n < 0, _.disabled = i < 0, Qr(m, sa, o), Qr(_, sa, r), c("arrows:updated", m, _, n, i) } } return { arrows: v, mount: b, destroy: w, update: C } }, Autoplay: function (t, e, n) { var i, o, r = Vs(t), s = r.on, a = r.bind, c = r.emit, l = Xs(n.interval, t.go.bind(t, ">"), (function (t) { var e = d.bar; e && Jr(e, "width", 100 * t + "%"), c("autoplay:playing", t) })), u = l.isPaused, d = e.Elements, f = e.Elements, h = f.root, p = f.toggle, g = n.autoplay, m = "pause" === g; function _() { u() && e.Slides.isEnough() && (l.start(!n.resetProgress), o = i = m = !1, y(), c(Ws)) } function v(t) { void 0 === t && (t = !0), m = !!t, y(), u() || (l.pause(), c(qs)) } function b() { m || (i || o ? v(!1) : _()) } function y() { p && (jr(p, Ia, !m), Qr(p, sa, n.i18n[m ? "play" : "pause"])) } function w(t) { var i = e.Slides.getAt(t); l.set(i && +es(i.slide, Ua) || n.interval) } return { mount: function () { g && (n.pauseOnHover && a(h, "mouseenter mouseleave", (function (t) { i = "mouseenter" === t.type, b() })), n.pauseOnFocus && a(h, "focusin focusout", (function (t) { o = "focusin" === t.type, b() })), p && a(p, "click", (function () { m ? _() : v(!0) })), s([Ls, js, Is], l.rewind), s(Ls, w), p && Qr(p, ia, d.track.id), m || _(), y()) }, destroy: l.cancel, play: _, pause: v, isPaused: u } }, Cover: function (t, e, n) { var i = Vs(t).on; function o(t) { e.Slides.forEach((function (e) { var n = Br(e.container || e.slide, "img"); n && n.src && r(t, n, e) })) } function r(t, e, n) { n.style("background", t ? 'center/cover no-repeat url("' + e.src + '")' : "", !0), Zr(e, t ? "none" : "") } return { mount: function () { n.cover && (i(Bs, wr(r, !0)), i([ks, Ms, Is], wr(o, !0))) }, destroy: wr(o, !1) } }, Scroll: function (t, e, n) { var i, o, r = Vs(t), s = r.on, a = r.emit, c = t.state.set, l = e.Move, u = l.getPosition, d = l.getLimit, f = l.exceededLimit, h = l.translate, p = t.is(Va), g = 1; function m(t, n, r, s, d) { var h = u(); if (b(), r && (!p || !f())) { var m = e.Layout.sliderSize(), y = As(t) * m * _s(bs(t) / m) || 0; t = l.toPosition(e.Controller.toDest(t % m)) + y } var w = ys(h, t, 1); g = 1, n = w ? 0 : n || ms(bs(t - h) / 1.5, 800), o = s, i = Xs(n, _, wr(v, h, t, d), 1), c(5), a(js), i.start() } function _() { c(3), o && o(), a(Fs) } function v(t, e, i, r) { var s, a, c = u(), l = (t + (e - t) * (s = r, (a = n.easingFunc) ? a(s) : 1 - Math.pow(1 - s, 4)) - c) * g; h(c + l), p && !i && f() && (g *= .6, bs(l) < 10 && m(d(f(!0)), 600, !1, o, !0)) } function b() { i && i.cancel() } function y() { i && !i.isPaused() && (b(), _()) } return { mount: function () { s(Ls, b), s([Ms, Is], y) }, destroy: b, scroll: m, cancel: y } }, Drag: function (t, e, n) { var i, o, r, s, a, c, l, u, d = Vs(t), f = d.on, h = d.emit, p = d.bind, g = d.unbind, m = t.state, _ = e.Move, v = e.Scroll, b = e.Controller, y = e.Elements.track, w = e.Media.reduce, E = e.Direction, A = E.resolve, C = E.orient, x = _.getPosition, T = _.exceededLimit, S = !1; function k() { var t = n.drag; z(!t), s = "free" === t } function O(t) { if (c = !1, !l) { var e = F(t); i = t.target, o = n.noDrag, Wr(i, "." + ka + ", ." + Ca) || o && Wr(i, o) || !e && t.button || (b.isBusy() ? ss(t, !0) : (u = e ? y : window, a = m.is([4, 5]), r = null, p(u, Ba, L, Ya), p(u, Ra, D, Ya), _.cancel(), v.cancel(), I(t))) } var i, o } function L(e) { if (m.is(6) || (m.set(6), h("drag")), e.cancelable) if (a) { _.translate(i + M(e) / (S && t.is(Va) ? 5 : 1)); var o = N(e) > 200, r = S !== (S = T()); (o || r) && I(e), c = !0, h("dragging"), ss(e) } else (function (t) { return bs(M(t)) > bs(M(t, !0)) })(e) && (a = function (t) { var e = n.dragMinThreshold, i = Tr(e), o = i && e.mouse || 0, r = (i ? e.touch : +e) || 10; return bs(M(t)) > (F(t) ? r : o) }(e), ss(e)) } function D(i) { m.is(6) && (m.set(3), h("dragged")), a && (function (i) { var o = function (e) { if (t.is(Xa) || !S) { var n = N(e); if (n && n < 200) return M(e) / n } return 0 }(i), r = function (t) { return x() + As(t) * gs(bs(t) * (n.flickPower || 600), s ? 1 / 0 : e.Layout.listSize() * (n.flickMaxPages || 1)) }(o), a = n.rewind && n.rewindByDrag; w(!1), s ? b.scroll(r, 0, n.snap) : t.is(Ka) ? b.go(C(As(o)) < 0 ? a ? "<" : "-" : a ? ">" : "+") : t.is(Va) && S && a ? b.go(T(!0) ? ">" : "<") : b.go(b.toDest(r), !0), w(!0) }(i), ss(i)), g(u, Ba, L), g(u, Ra, D), a = !1 } function P(t) { !l && c && ss(t, !0) } function I(t) { r = o, o = t, i = x() } function M(t, e) { return j(t, e) - j($(t), e) } function N(t) { return us(t) - us($(t)) } function $(t) { return o === t && r || o } function j(t, e) { return (F(t) ? t.changedTouches[0] : t)["page" + A(e ? "Y" : "X")] } function F(t) { return "undefined" != typeof TouchEvent && t instanceof TouchEvent } function z(t) { l = t } return { mount: function () { p(y, Ba, Ar, Ya), p(y, Ra, Ar, Ya), p(y, qa, O, Ya), p(y, "click", P, { capture: !0 }), p(y, "dragstart", ss), f([ks, Ms], k) }, disable: z, isDragging: function () { return a } } }, Keyboard: function (t, e, n) { var i, o, r = Vs(t), s = r.on, a = r.bind, c = r.unbind, l = t.root, u = e.Direction.resolve; function d() { var t = n.keyboard; t && (i = "global" === t ? window : l, a(i, Ja, p)) } function f() { c(i, Ja) } function h() { var t = o; o = !0, Er((function () { o = t })) } function p(e) { if (!o) { var n = Ga(e); n === u(Us) ? t.go("<") : n === u(Ys) && t.go(">") } } return { mount: function () { d(), s(Ms, f), s(Ms, d), s(Ls, h) }, destroy: f, disable: function (t) { o = t } } }, LazyLoad: function (t, e, n) { var i = Vs(t), o = i.on, r = i.off, s = i.bind, a = i.emit, c = "sequential" === n.lazyLoad, l = [Ds, Fs], u = []; function d() { br(u), e.Slides.forEach((function (t) { cs(t.slide, ec).forEach((function (e) { var i = es(e, Za), o = es(e, tc); if (i !== e.src || o !== e.srcset) { var r = n.classes.spinner, s = e.parentElement, a = Br(s, "." + r) || Gr("span", r, s); u.push([e, t, a]), e.src || Zr(e, "none") } })) })), c ? g() : (r(l), o(l, f), f()) } function f() { (u = u.filter((function (e) { var i = n.perPage * ((n.preloadPages || 1) + 1) - 1; return !e[1].isWithin(t.index, i) || h(e) }))).length || r(l) } function h(t) { var e = t[0]; Fr(t[1].slide, ja), s(e, "load error", wr(p, t)), Qr(e, "src", es(e, Za)), Qr(e, "srcset", es(e, tc)), Yr(e, Za), Yr(e, tc) } function p(t, e) { var n = t[0], i = t[1]; ls(i.slide, ja), "error" !== e.type && (os(t[2]), Zr(n, ""), a(Bs, n, i), a(Ns)), c && g() } function g() { u.length && h(u.shift()) } return { mount: function () { n.lazyLoad && (d(), o(Is, d)) }, destroy: wr(br, u), check: f } }, Pagination: function (t, e, n) { var i, o, r = Vs(t), s = r.on, a = r.emit, c = r.bind, l = e.Slides, u = e.Elements, d = e.Controller, f = d.hasFocus, h = d.getIndex, p = d.go, g = e.Direction.resolve, m = u.pagination, _ = []; function v() { i && (os(m ? yr(i.children) : i), ls(i, o), br(_), i = null), r.destroy() } function b(t) { p(">" + t, !0) } function y(t, e) { var n = _.length, i = Ga(e), o = w(), r = -1; i === g(Ys, !1, o) ? r = ++t % n : i === g(Us, !1, o) ? r = (--t + n) % n : "Home" === i ? r = 0 : "End" === i && (r = n - 1); var s = _[r]; s && (ts(s.button), p(">" + r), ss(e, !0)) } function w() { return n.paginationDirection || n.direction } function E(t) { return _[d.toPage(t)] } function A() { var t = E(h(!0)), e = E(h()); if (t) { var n = t.button; ls(n, Ia), Yr(n, ra), Qr(n, ea, -1) } if (e) { var o = e.button; Fr(o, Ia), Qr(o, ra, !0), Qr(o, ea, "") } a("pagination:updated", { list: i, items: _ }, t, e) } return { items: _, mount: function e() { v(), s([Ms, Is, Rs], e); var r = n.pagination; m && Zr(m, r ? "" : "none"), r && (s([Ls, js, Fs], A), function () { var e = t.length, r = n.classes, s = n.i18n, a = n.perPage, h = f() ? d.getEnd() + 1 : vs(e / a); Fr(i = m || Gr("ul", r.pagination, u.track.parentElement), o = Sa + "--" + w()), Qr(i, ta, "tablist"), Qr(i, sa, s.select), Qr(i, la, w() === Js ? "vertical" : ""); for (var p = 0; p < h; p++) { var g = Gr("li", null, i), v = Gr("button", { class: r.page, type: "button" }, g), E = l.getIn(p).map((function (t) { return t.slide.id })), A = !f() && a > 1 ? s.pageX : s.slideX; c(v, "click", wr(b, p)), n.paginationKeyboard && c(v, "keydown", wr(y, p)), Qr(g, ta, "presentation"), Qr(v, ta, "tab"), Qr(v, ia, E.join(" ")), Qr(v, sa, Cs(A, p + 1)), Qr(v, ea, -1), _.push({ li: g, button: v, page: p }) } }(), A(), a("pagination:mounted", { list: i, items: _ }, E(t.index))) }, destroy: v, getAt: E, update: A } }, Sync: function (t, e, n) { var i = n.isNavigation, o = n.slideFocus, r = []; function s() { var e, n; t.splides.forEach((function (e) { e.isParent || (c(t, e.splide), c(e.splide, t)) })), i && ((n = (e = Vs(t)).on)(Ps, u), n("sk", d), n([ks, Ms], l), r.push(e), e.emit(Hs, t.splides)) } function a() { r.forEach((function (t) { t.destroy() })), br(r) } function c(t, e) { var n = Vs(t); n.on(Ls, (function (t, n, i) { e.go(e.is(Xa) ? i : t) })), r.push(n) } function l() { Qr(e.Elements.list, la, n.direction === Js ? "vertical" : "") } function u(e) { t.go(e.index) } function d(t, e) { Nr(nc, Ga(e)) && (u(t), ss(e)) } return { setup: wr(e.Media.set, { slideFocus: Lr(o) ? i : o }, !0), mount: s, destroy: a, remount: function () { a(), s() } } }, Wheel: function (t, e, n) { var i = Vs(t).bind, o = 0; function r(i) { if (i.cancelable) { var r = i.deltaY, s = r < 0, a = us(i), c = n.wheelMinThreshold || 0, l = n.wheelSleep || 0; bs(r) > c && a - o > l && (t.go(s ? "<" : ">"), o = a), function (i) { return !n.releaseWheel || t.state.is(4) || -1 !== e.Controller.getAdjacent(i) }(s) && ss(i) } } return { mount: function () { n.wheel && i(e.Elements.track, "wheel", r, Ya) } } }, Live: function (t, e, n) { var i = Vs(t).on, o = e.Elements.track, r = n.live && !n.isNavigation, s = Gr("span", Da), a = Xs(90, wr(c, !1)); function c(t) { Qr(o, fa, t), t ? (zr(o, s), a.start()) : (os(s), a.cancel()) } function l(t) { r && Qr(o, da, t ? "off" : "polite") } return { mount: function () { r && (l(!e.Autoplay.isPaused()), Qr(o, ha, !0), s.textContent = "", i(Ws, wr(l, !0)), i(qs, wr(l, !1)), i([Ds, Fs], wr(c, !0))) }, disable: l, destroy: function () { Yr(o, [da, ha, fa]), os(s) } } } }), oc = { type: "slide", role: "region", speed: 400, perPage: 1, cloneStatus: !0, arrows: !0, pagination: !0, paginationKeyboard: !0, interval: 5e3, pauseOnHover: !0, pauseOnFocus: !0, resetProgress: !0, easing: "cubic-bezier(0.25, 1, 0.5, 1)", drag: !0, direction: "ltr", trimSpace: !0, focusableNodes: "a, button, textarea, input, select, iframe", live: !0, classes: Wa, i18n: { prev: "Previous slide", next: "Next slide", first: "Go to first slide", last: "Go to last slide", slideX: "Go to slide %s", pageX: "Go to page %s", play: "Start autoplay", pause: "Pause autoplay", carousel: "carousel", slide: "slide", select: "Select a slide to show", slideLabel: "%s of %s" }, reducedMotion: { speed: 0, rewindSpeed: 0, autoplay: "pause" } }; function rc(t, e, n) { var i = e.Slides; function o() { i.forEach((function (t) { t.style("transform", "translateX(-" + 100 * t.index + "%)") })) } return { mount: function () { Vs(t).on([ks, Is], o) }, start: function (t, e) { i.style("transition", "opacity " + n.speed + "ms " + n.easing), Er(e) }, cancel: Ar } } function sc(t, e, n) { var i, o = e.Move, r = e.Controller, s = e.Scroll, a = e.Elements.list, c = wr(Jr, a, "transition"); function l() { c(""), s.cancel() } return { mount: function () { Vs(t).bind(a, "transitionend", (function (t) { t.target === a && i && (l(), i()) })) }, start: function (e, a) { var l = o.toPosition(e, !0), u = o.getPosition(), d = function (e) { var i = n.rewindSpeed; if (t.is(Va) && i) { var o = r.getIndex(!0), s = r.getEnd(); if (0 === o && e >= s || o >= s && 0 === e) return i } return n.speed }(e); bs(l - u) >= 1 && d >= 1 ? n.useScroll ? s.scroll(l, d, !1, a) : (c("transform " + d + "ms " + n.easing), o.translate(l, !0), i = a) : (o.jump(e), a()) }, cancel: l } } var ac = function () { function t(e, n) { var i; this.event = Vs(), this.Components = {}, this.state = (i = 1, { set: function (t) { i = t }, is: function (t) { return Nr(Ir(t), i) } }), this.splides = [], this._o = {}, this._E = {}; var o = Or(e) ? as(document, e) : e; ps(o, o + " is invalid."), this.root = o, n = Kr({ label: es(o, sa) || "", labelledby: es(o, aa) || "" }, oc, t.defaults, n || {}); try { Kr(n, JSON.parse(es(o, hs))) } catch (t) { ps(!1, "Invalid JSON") } this._o = Object.create(Kr({}, n)) } var e, n, i = t.prototype; return i.mount = function (t, e) { var n = this, i = this.state, o = this.Components; return ps(i.is([1, 7]), "Already mounted!"), i.set(1), this._C = o, this._T = e || this._T || (this.is(Ka) ? rc : sc), this._E = t || this._E, Vr(Xr({}, ic, this._E, { Transition: this._T }), (function (t, e) { var i = t(n, o, n._o); o[e] = i, i.setup && i.setup() })), Vr(o, (function (t) { t.mount && t.mount() })), this.emit(ks), Fr(this.root, Pa), i.set(3), this.emit(Os), this }, i.sync = function (t) { return this.splides.push({ splide: t }), t.splides.push({ splide: this, isParent: !0 }), this.state.is(3) && (this._C.Sync.remount(), t.Components.Sync.remount()), this }, i.go = function (t) { return this._C.Controller.go(t), this }, i.on = function (t, e) { return this.event.on(t, e), this }, i.off = function (t) { return this.event.off(t), this }, i.emit = function (t) { var e; return (e = this.event).emit.apply(e, [t].concat(yr(arguments, 1))), this }, i.add = function (t, e) { return this._C.Slides.add(t, e), this }, i.remove = function (t) { return this._C.Slides.remove(t), this }, i.is = function (t) { return this._o.type === t }, i.refresh = function () { return this.emit(Is), this }, i.destroy = function (t) { void 0 === t && (t = !0); var e = this.event, n = this.state; return n.is(1) ? Vs(this).on(Os, this.destroy.bind(this, t)) : (Vr(this._C, (function (e) { e.destroy && e.destroy(t) }), !0), e.emit(zs), e.destroy(), t && br(this.splides), n.set(7)), this }, e = t, (n = [{ key: "options", get: function () { return this._o }, set: function (t) { this._C.Media.set(t, !0, !0) } }, { key: "length", get: function () { return this._C.Slides.getLength(!0) } }, { key: "index", get: function () { return this._C.Controller.getIndex() } }]) && mr(e.prototype, n), Object.defineProperty(e, "prototype", { writable: !1 }), t }(), cc = ac; function lc() { var t, e; if (void 0 !== window.guLocationData) { var n = (null === (t = window.guLocationData) || void 0 === t ? void 0 : t.locations) || [], i = (null === (e = window.guLocationData) || void 0 === e ? void 0 : e.ajaxUrl) || "", o = document.querySelectorAll(".zip-code-search"); 0 !== o.length && o.forEach((function (t) { var e, o, r = t.querySelector('input[type="text"]'), s = t.querySelector(".zip-code-results"); if (r && s) { r.addEventListener("input", (function (t) { this.value = this.value.replace(/[^0-9]/g, ""), this.value.length > 5 && (this.value = this.value.slice(0, 5)) })); var a = (e = function () { return function (t, e) { var o = t.value.trim(); if (o) { var r, s = (r = o, n.filter((function (t) { if (!t || !t.zipCodes || !Array.isArray(t.zipCodes)) return !1; try { return t.zipCodes.some((function (t) { return null != t && t.toString().startsWith(r) })) } catch (t) { return !1 } }))); s.length ? e.innerHTML = s.map((function (t) { return '<a href="'.concat(t.website, '" target="_blank">').concat(t.name, "</a>") })).join("") : /^\d{5}$/.test(o) ? (e.innerHTML = "<span>Searching...</span>", function (t) { return new Promise((function (e) { jQuery.ajax({ url: i, type: "POST", data: { action: "resi_zip_lookup", zip: t } }).done((function (t) { t.success ? e(t.data) : e(null) })).fail((function (t) { console.error("Error fetching location from server:", t), e(null) })) })) }(o).then((function (t) { e.innerHTML = t ? '<a href="'.concat(t.website, '" target="_blank">').concat(t.name, "</a>") : '<a href="/contact-us/">Get an Estimate</a>' })).catch((function (t) { console.error("AJAX lookup error:", t), e.innerHTML = '<a href="/contact-us/">Get an Estimate</a>' }))) : e.innerHTML = "" } else e.innerHTML = "" }(r, s) }, function () { for (var t = this, n = arguments.length, i = new Array(n), r = 0; r < n; r++)i[r] = arguments[r]; clearTimeout(o), o = setTimeout((function () { return e.apply(t, i) }), 300) }); r.addEventListener("input", a) } })) } } cc.defaults = {}, cc.STATES = vr, window.addEventListener("resize", gr), document.addEventListener("DOMContentLoaded", (function () { var t, e; gr(), t = {}, e = {}, document.querySelectorAll(".design-slider").forEach((function (e) { var n = e.dataset.section; if (n) { new cc(e).mount(), t[n] = 0; var i = e.querySelectorAll(".slider-thumb"), o = document.getElementById("".concat(n, "-active-image")); i.length > 0 && o && i.forEach((function (e, r) { e.addEventListener("click", (function (s) { s.preventDefault(), t[n] = r, i.forEach((function (t) { return t.classList.remove("active") })), e.classList.add("active"); var a = e.dataset.image, c = e.dataset.alt; o.style.opacity = "0", setTimeout((function () { o.src = a, o.alt = c, o.style.opacity = "1" }), 300) })) })) } })), document.querySelectorAll('[id$="LightboxModal"]').forEach((function (n) { var i = n.id.replace("LightboxModal", ""), o = n.querySelector(".lightbox-slider"); o && (n.addEventListener("shown.bs.modal", (function () { e[i] ? e[i].go(t[i] || 0) : e[i] = new cc(o, { type: "loop", perPage: 1, perMove: 1, gap: 0, pagination: !1, arrows: !0, keyboard: !0, start: t[i] || 0 }).mount() })), n.addEventListener("hidden.bs.modal", (function () { }))) })), lc(), function () { var t = window.location.search; if (console.log("storeUTM called with queryString:", t), t && t.includes("utm_")) { var e = { params: t, timestamp: Date.now() }; localStorage.setItem("resi_utm_params", JSON.stringify(e)) } var n = "", i = localStorage.getItem("resi_utm_params"); if (i) try { e = JSON.parse(i), !(Date.now() - e.timestamp > 432e6) && e.params && (n = e.params) } catch (t) { n = "" } var o = document.querySelectorAll(".wpforms-field-container"); o && o.length > 0 && o.forEach((function (t) { var e = t.querySelector('input[type="hidden"]'); !e || e.value && "" !== e.value || !n || (e.value = n) })) }() })), [].forEach.call(document.querySelectorAll(".search-form"), (function (t) { t.addEventListener("submit", (function (e) { var n = t.querySelector("input"); n.value.length < 1 && (e.preventDefault(), n.focus()) })) })), [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]')).map((function (t) { return new bo(t, { trigger: "focus" }) })), document.addEventListener("DOMContentLoaded", (function () { document.querySelectorAll("#wrapper > div a").forEach((function (t) { var e = t.getAttribute("href"); e && e.match(/\/[^\/]+\/contact-us/) && t.addEventListener("click", (function (t) { t.preventDefault(); var e = document.getElementById("scheduleModal"); e && new Oi(e).show() })) })) })) }() }();